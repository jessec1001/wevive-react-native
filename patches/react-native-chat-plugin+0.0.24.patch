diff --git a/node_modules/react-native-chat-plugin/ChatContainer.js b/node_modules/react-native-chat-plugin/ChatContainer.js
index 621e6d1..0b72dcd 100644
--- a/node_modules/react-native-chat-plugin/ChatContainer.js
+++ b/node_modules/react-native-chat-plugin/ChatContainer.js
@@ -14,6 +14,8 @@ import { UserContext } from "../../src/context/UserContext";
 import NetInfo from '@react-native-community/netinfo';
 import Sound from "react-native-sound";
 import { addUnreadCount, updateCount } from "react-native-chat-plugin/utils/unread-counter";
+import { CommonActions } from "@react-navigation/routers";
+import AsyncStorage from "@react-native-async-storage/async-storage";
 const styles = StyleSheet.create({
   errorView: {
     position: "absolute",
@@ -34,21 +36,155 @@ const styles = StyleSheet.create({
   },
 });
 
+const playSound = () => {
+  var whoosh = new Sound('chord.wav', Sound.MAIN_BUNDLE, (error) => {
+    if (error) {
+      console.log('failed to load the sound', error);
+      return;
+    }
+    whoosh.play((success) => {});
+  });
+  whoosh.release();
+}
 
+const getEntity = (list, params) => {
+  const entity = {};
+  const keys = Object.keys(list);
+  for (i in keys) {
+    if (params.indexOf(keys[i]) !== -1) {
+      entity[keys[i]] = list[keys[i]];
+    }
+  }
+  return entity;
+}
+const getConversationEntity = (list) => {
+  return getEntity(list, ['created_by','is_archive','group_id','is_delete','is_read','is_mute','created_at','is_pin','name'])
+}
+const getUserEntity = (list) => {
+  return getEntity(list, ['userId','phone_number','seen_at','username','avatarUrl'])
+}
+const getMessageEntity = (list) => {
+  return getEntity(list, ['event_id','is_read','is_starred','text','is_delivered','retry_at', 'type'])
+}
 
+let init = false;
 export default function ChatContainer({ options, contacts, children }) {
   const ctx = React.useContext(ChatContext);
+  const userContext = React.useContext(UserContext);
   const socket = getSocket();
-  const [init, setInit] = React.useState(false);
+  //const [init, setInit] = React.useState(false);
   const [retry, setRetry] = React.useState(false);
+  const [loaded, setLoaded] = React.useState(false);
   const [connected, setConnected] = React.useState(true);
   const [showRetryButton, setShowRetryButton] = React.useState(false);
   const user = ctx.getUser();
   const users = ctx.getUsers();
-  const authenticationCallback = (res) => {
+  React.useEffect(() => {
+    const unsubscribe = navigation.addListener('focus', () => {
+      if (connected) {
+        setConnected(connected++);
+      }
+    });
+
+    // Return the function to unsubscribe from the event so it gets removed on unmount
+    return unsubscribe;
+  }, [navigation]);
+
+  // get latest conversations from the DB:
+  
+  React.useEffect(() => {
+    if (!connected || !options || !loaded) {
+      return false;
+    };
+    const salt = '';
+    if (options.userToken != "" && (!socket.chat_token || socket.chat_token != options.userToken)) {
+      ctx.setAuthInfo(options, userContext.authData);
+      socket.chat_public_key = global.encryptionKeys.public_key;
+      socket.chat_private_key = global.encryptionKeys.private_key;
+      socket.chat_token = options.userToken;
+      ctx.authenticate({...options, public_key: socket.chat_public_key, salt}, authenticationCallback, errorCallback);
+    }
+  },[connected, options, loaded]);
+  
+
+  const handleEventCreated = React.useCallback(async function ({ event }) {
+    if (event && event.id) {
+      const [decryptedEvent] = await decryptEventsBasic(event.conversationId, [event], socket.chat_private_key, ctx);
+      if (!event.owner || event.owner.id != user.id) {
+        if (event.owner?.id && !ctx.isUserBlocked(event.owner.id)) {
+          if (!ctx.isUserMuted(event.owner.id)) {
+            playSound();
+            addUnreadCount(1);
+            ctx.incrementUnreadCounts(
+              { conversationId: event.conversationId, count: 1 }
+            );
+          }
+          ctx.addEvent(decryptedEvent);
+        }
+        ctx.saveMessageToDB(event.conversationId, event.text, event.owner ? event.owner.id : 0, event.type, event.id, event.time);
+      } else {
+
+      }
+      await ctx.saveUserToDB(event.owner.id, event.owner.avatar, event.owner.username, event.owner.phone_number, event.owner.lastOnline);
+    }
+  },[users]);
+  async function handleEventRead ({ conversationId, eventId, userId }) {
+    if (conversationId && userId) {
+      if (user.id != userId) {
+        ctx.updateEventReads(conversationId, eventId, userId);
+      }
+    }
+  }
+  async function handleConversationCreated({ conversation }) {
+    const newConversation = await decryptConversations([conversation], socket.chat_private_key, ctx);
+    if (!ctx.isUserBlocked(newConversation[0].createdBy)) {
+      if (!newConversation[0].hidden) ctx.addConversation(newConversation[0]);
+    }
+    ctx.saveConversationToDB(conversation);
+  }
+  const handleTyping = ({userId, conversationId}) => {
+    if (conversationId && userId) {
+      if (userId != socket.chat_user_id) {
+        if (!ctx.isUserBlocked(userId)) {
+          ctx.setTyping({ conversationId, userId });
+          setTimeout(() => {
+            ctx.unsetTyping({ conversationId, userId });
+          }, 1500);
+        }
+      }
+    }
+  };
+
+  const enableHandlers = () => {
+    socket.on("events:typing", handleTyping);
+    socket.on("events:read_event", handleEventRead);
+    socket.on("events:event_created", handleEventCreated);
+    socket.on("conversations:created", handleConversationCreated);
+  }
+  const disableHandlers = () => {
+    socket.off("events:typing", handleTyping);
+    socket.off("events:read_event", handleEventRead);
+    socket.off("events:event_created", handleEventCreated);
+    socket.off("conversations:created", handleConversationCreated);
+  }
+  const errorCallback = (res) => {
+    /*AsyncStorage.removeItem('userId');
+    AsyncStorage.removeItem('userName');
+    AsyncStorage.removeItem('userToken');
+    AsyncStorage.removeItem('sessionToken');
+    global.navigation.dispatch(
+      CommonActions.reset({
+        index: 0,
+        routes: [{name: 'Auth'}],
+      }),
+    );*/
+  }
+  const authenticationCallback = React.useCallback((res) => {
+
     if (!res || !res.user) return;
     setTimeout(() => {
       socket.chat_user_id = res.user.id;
+      updateLastOnline();
       /*resendEncryptionKeys(ctx, socket, res.user.id).then(() => {
 
       }).catch((error) => {
@@ -79,252 +215,161 @@ export default function ChatContainer({ options, contacts, children }) {
       */
       emitEvents();
     }, 50);
-  };
+  },[users]);
   React.useEffect(() => {
-    resendFailed(user.id)
-  }, [user.id])
+    //
+    if (connected && user) {
+      if (user && user.id) {
+        resendFailed(user.id)
+      }
+    }
+  }, [connected, user])
   React.useEffect(() => {
     ctx.addPhoneContacts(contacts);
   }, [contacts])
-  React.useEffect(() => {
-    if (!connected || !options) return;
-    ctx.setAuthInfo(options, userContext.authData);
-    /*getEncryptionKeys(ctx).then(({ private_key, public_key, salt }) => {
-      socket.chat_public_key = public_key;
-      socket.chat_private_key = private_key;
-      socket.chat_token = options.token;
-      if (options.token != "") {
-        ctx.authenticate({...options,public_key, salt}, authenticationCallback);
-      }
-    });*/
-    socket.chat_public_key = global.encryptionKeys.public_key;
-    socket.chat_private_key = global.encryptionKeys.private_key;
-    socket.chat_token = options.token;
-    const salt = '';
-    if (options.token != "") {
-      ctx.authenticate({...options, public_key: socket.chat_public_key, salt}, authenticationCallback);
-    }
-  },[connected, options]);
-const resendFailed = (userId) => {
-  if (!userId) return;
-  ctx.getFailedMessagesFromDB(userId).then((events)=> {
-    for (let i=0;i<events.length;i++) {
-      let e = events.item(i);
-      socket.emit("events:new_message", { conversationId: e.group_id, message: e.text, nonce: e.id }, ({ success, error, event, nonce }) => {
-        if (!success && error) {
+  const resendFailed = (userId) => {
+    if (!userId) return;
+    ctx.getFailedMessagesFromDB(userId).then((events)=> {
+      for (let i=0;i<events.length;i++) {
+        let e = events.item(i);
+        socket.emit("events:new_message", { conversationId: e.group_id, message: e.text, nonce: e.id }, ({ success, error, event, nonce }) => {
+          if (!success && error) {
   
-        } else if (event) {
-          ctx.updateEvent(e.group_id, e.id, {...event, is_delivered:true})
-          ctx.updateMessageEvent(e.id, event)
-        }
+          } else if (event) {
+            ctx.updateEvent(e.group_id, e.id, {...event, is_delivered:true})
+            ctx.updateMessageEvent(e.id, event)
+          }
+        });
+      }
+    });
+  }
+  const updateLastOnline = () => {
+    const ids = users.map(u => u.id);
+    if (ids.length) {
+      socket.emit("users:get_last_online", {ids}, async (res) => {
+        ctx.setLastOnline(res.lastOnline)
       });
     }
-  });
-}
-const updateLastOnline = () => {
-  const ids = users.map(u => u.id);
-  if (ids.length) {
-    socket.emit("users:get_last_online", {ids}, async (res) => {
-      ctx.setLastOnline(res.lastOnline)
-    });
   }
-}
-const userContext = React.useContext(UserContext);
-const emitEvents = (recreateKeys = false) => {
-  // get latest conversations from the server:
-  ctx.getLatestEventFromDB().then((event)=> {
-    const options = event ? {since: 0} : {since: 0};
-    updateCount();
-    socket.emit("conversations:fetch", options, async (res) => {
-      if (res && res.success && Array.isArray(res.conversations)) {
-        const conversations = await decryptConversationsBasic(res.conversations.filter(c => c !== null), socket.chat_private_key, ctx, recreateKeys);
-        ctx.setConversations(conversations);
-        conversations.map(c=>{
-          ctx.saveConversationToDB(c)
-          c.participants && c.participants.map(u=>{
-            if (u.id) {
-              ctx.saveUserToDB(u.id, u.avatar, u.username, u.phone_number, u.lastOnline);
-              ctx.addUser(u);
+  const emitEvents = (recreateKeys = false) => {
+    // get latest conversations from the server:
+    ctx.getLatestEventFromDB().then((event)=> {
+      const options = event ? {since: 0} : {since: 0};
+      updateCount();
+      socket.emit("conversations:fetch", options, async (res) => {
+        if (res && res.success && Array.isArray(res.conversations)) {
+          const conversations = (await decryptConversationsBasic(res.conversations.filter(c => c !== null), socket.chat_private_key, ctx, recreateKeys))
+          .map(c=>{
+            ctx.saveConversationToDB(c);
+            c.participants && c.participants.map(u=>{
+              if (u.id) {
+                ctx.saveUserToDB(u.id, u.avatar, u.username, u.phone_number, u.lastOnline);
+                ctx.addUser(u);
+              }
+            });
+            const event = c.lastEvent;
+            if (event) {
+              const isUserBlocked = ctx.isUserBlocked(event.owner.id);
+              if (!isUserBlocked) {
+                ctx.saveMessageToDB(c.id, event?.text, event?.owner ? event.owner.id : 0, event?.type, event?.id, event?.time);
+              }
             }
+            return c;
+            //c.lastEvent
+          }).filter(c=> {
+            const blocked = ctx.isUserBlocked(c.createdBy);
+            return !blocked;
           });
-          const event = c.lastEvent;
-          ctx.saveMessageToDB(c.id, event?.text, event?.owner ? event.owner.id : 0, event?.type, event?.id, event?.time);
-          //c.lastEvent
-        });
+          ctx.setConversations(conversations);
+        }
+      });
+    });
+    //get unread count.
+    socket.emit("events:get_unread_count", ({ success, stats }) => {
+      if (success && stats && Array.isArray(stats) && stats.length > 0) {
+        ctx.updateUnreadCounts({ stats });
       }
     });
-  });
-  //get unread count.
-  socket.emit("events:get_unread_count", ({ success, stats }) => {
-    if (success && stats && Array.isArray(stats) && stats.length > 0) {
-      ctx.updateUnreadCounts({ stats });
-    }
-  });
-  updateLastOnline();
-  resendFailed(user.id);
-};
+    updateLastOnline();
+  };
   React.useEffect(() => {
     //if (init) return;
-    //init = true;
     //return;
     // get latest users from the DB:
-    ctx.getUsersFromDB().then((users)=> {
-      if (init) return;
-      const usersList = {};
-      for (let i=0;i<users.length;i++) {
-        let user = users.item(i);
-        user.userId = user.id;
-        user.avatar = user.path;
-        user.phone_number = user.username;
-        delete user.path;
-        user.lastOnline = user.lastOnline * 1000;
-        ctx.addUser(user);
-        usersList[user.id] = user;
-      }
-      if (!userContext.authData.username) {
-        userContext.setAuthData(usersList[userContext.authData.id]);
-      }
-      
-      ctx.getConversationsFromDB().then((conversations)=> {
-        let conversationsArray = {};
-        for (let i=0;i<conversations.length;i++) {
-          let conversation = conversations.item(i);
-          if (typeof conversationsArray[conversation.groupId] == 'undefined') {
-            const conversationEntity = getConversationEntity(conversation)
-            
-            conversationEntity.id = conversation.groupId;
-            conversationEntity.events = [];
-            conversationEntity.participants = [];
-            conversationEntity.time = new Date(conversation.createdAt * 1000);
-            conversationEntity.createdAt = conversation.createdAt;
-            conversationEntity.pinned = conversation.is_pin;
-            conversationEntity.muted = conversation.is_mute;
-            conversationEntity.archived = conversation.is_archive;
-            conversationsArray[conversation.groupId] = conversationEntity;
-          }
-          const messageEntity = getMessageEntity(conversation);
-          messageEntity.id = conversation.eventId;
-          //messageEntity.type = "MESSAGE";
-          conversationsArray[conversation.groupId].lastEvent = messageEntity;
-          const userEntity = getUserEntity(conversation);
-          userEntity.avatar = userEntity.avatarUrl;
-          userEntity.id = String(conversation.userId);
-          messageEntity.owner = usersList[conversation.eventUserId];
-          messageEntity.type = "MESSAGE";
-          messageEntity.time = new Date(conversation.eventCreatedAt * 1000);
-          if (messageEntity.time > conversationsArray[conversation.groupId].time) {
-            conversationsArray[conversation.groupId].time = messageEntity.time;
-          }
-          const userIdx = conversationsArray[conversation.groupId].participants.findIndex(c => c.userId == userEntity.id);
-          if (userIdx == -1) {
-            const avatar = usersList[userEntity.id]?.avatar;
-            if (avatar) {
-              userEntity.avatar = avatar;
+    if (!init) {
+      init = true;
+      ctx.getUsersFromDB().then((usersFromDB)=> {
+        const usersList = {};
+        for (let i=0;i<usersFromDB.length;i++) {
+          let user = usersFromDB.item(i);
+          user.userId = user.id;
+          user.avatar = "file://"+user.path;
+          //user.phone_number = user.username;
+          delete user.path;
+          user.lastOnline = user.lastOnline * 1000;
+          usersList[user.id] = user;
+        }
+        ctx.addUsers(Object.values(usersList));
+        if (!userContext.authData.username && userContext.authData.id) {
+          userContext.setAuthData(usersList[userContext.authData.id]);
+        }
+        ctx.getConversationsFromDB().then((conversations)=> {
+          //return false;
+          let conversationsArray = {};
+          for (let i=0;i<conversations.length;i++) {
+            let conversation = conversations.item(i);
+            if (typeof conversationsArray[conversation.groupId] == 'undefined') {
+              const conversationEntity = getConversationEntity(conversation)
+              conversationEntity.id = conversation.groupId;
+              conversationEntity.events = [];
+              conversationEntity.participants = [];
+              conversationEntity.time = new Date(conversation.createdAt * 1000);
+              conversationEntity.createdAt = conversation.createdAt;
+              conversationEntity.pinned = conversation.is_pin;
+              conversationEntity.muted = conversation.is_mute;
+              conversationEntity.archived = conversation.is_archive;
+              conversationEntity.avatar = conversation.group_avatar;
+              conversationsArray[conversation.groupId] = conversationEntity;
+            }
+            const messageEntity = getMessageEntity(conversation);
+            messageEntity.id = conversation.eventId;
+            //messageEntity.type = "MESSAGE";
+            const userEntity = getUserEntity(conversation);
+            userEntity.avatar = userEntity.avatarUrl;
+            userEntity.id = String(conversation.userId);
+            userEntity.name = userEntity.username;
+            userEntity.username = userEntity.phone_number;
+            messageEntity.owner = usersList[conversation.eventUserId];
+            messageEntity.type = "MESSAGE";
+            messageEntity.time = Math.floor(+new Date(conversation.eventCreatedAt*1000));
+            if ((messageEntity.time < conversationsArray[conversation.groupId].time) || !conversationsArray[conversation.groupId].lastEvent) {
+              conversationsArray[conversation.groupId].time = messageEntity.time;
+              conversationsArray[conversation.groupId].lastEvent = messageEntity;
+            }
+            const userIdx = conversationsArray[conversation.groupId].participants.findIndex(c => c.userId == userEntity.id);
+            if (userIdx == -1) {
+              const avatar = usersList[userEntity.id]?.avatar;
+              if (avatar) {
+                userEntity.avatar = avatar;
+              }
+              conversationsArray[conversation.groupId].participants.push(userEntity);
+            }
+            const messageIdx = conversationsArray[conversation.groupId].events.findIndex(e => e.id == messageEntity.event_id);
+            if (messageIdx == -1) {
+              conversationsArray[conversation.groupId].events.push(messageEntity);
             }
-            conversationsArray[conversation.groupId].participants.push(userEntity);
-          }
-          const messageIdx = conversationsArray[conversation.groupId].events.findIndex(e => e.id == messageEntity.event_id);
-          if (messageIdx == -1) {
-            conversationsArray[conversation.groupId].events.push(messageEntity);
           }
-         
-        }
-        const conversationsArrayR = Object.values(conversationsArray).sort((a,b)=> {
-          return a.time > b.time
+          const conversationsArrayR = Object.values(conversationsArray).sort((a,b)=> {
+            return a.time > b.time
+          });
+          ctx.setConversations(conversationsArrayR);
         });
-        ctx.setConversations(conversationsArrayR);
-        setInit(true);
-        updateLastOnline();
-        resendFailed(user.id);
       });
-    });
-    const getEntity = (list, params) => {
-      const entity = {};
-      const keys = Object.keys(list);
-      for (i in keys) {
-        if (params.indexOf(keys[i]) !== -1) {
-          entity[keys[i]] = list[keys[i]];
-        }
-      }
-      return entity;
-    }
-    const getConversationEntity = (list) => {
-      return getEntity(list, ['created_by','is_archive','group_id','is_delete','is_read','is_mute','created_at','is_pin','name'])
-    }
-    const getUserEntity = (list) => {
-      return getEntity(list, ['userId','phone_number','seen_at','username','avatarUrl'])
-    }
-    const getMessageEntity = (list) => {
-      return getEntity(list, ['event_id','is_read','is_starred','created_at','text','is_delivered','retry_at', 'type'])
+      setLoaded(true);
     }
-    // get latest conversations from the DB:
     
-    const playSound = () => {
-      var whoosh = new Sound('chord.wav', Sound.MAIN_BUNDLE, (error) => {
-        if (error) {
-          console.log('failed to load the sound', error);
-          return;
-        }
-        // loaded successfully
-        //console.log('duration in seconds: ' + whoosh.getDuration() + 'number of channels: ' + whoosh.getNumberOfChannels());
-      
-        // Play the sound with an onEnd callback
-        whoosh.play((success) => {
-          if (success) {
-            console.log('successfully finished playing');
-          } else {
-            console.log('playback failed due to audio decoding errors');
-          }
-        });
-      });
       
-      // Reduce the volume by half
-      //whoosh.setVolume(0.5);
-      whoosh.release();
-    }
 
-    async function handleEventCreated ({ event }) {
-      if (event && event.id) {
-        const [decryptedEvent] = await decryptEventsBasic(event.conversationId, [event], socket.chat_private_key, ctx);
-        if (!event.owner || event.owner.id != ctx.getUserId()) {
-          playSound();
-          addUnreadCount(1);
-          ctx.addEvent(decryptedEvent);
-          ctx.incrementUnreadCounts(
-            { conversationId: event.conversationId, count: 1 }
-          );
-          ctx.saveMessageToDB(event.conversationId, event.text, event.owner ? event.owner.id : 0, event.type, event.id, event.time);
-        } else {
-        }
-        await ctx.saveUserToDB(event.owner.id, event.owner.avatar, event.owner.username, event.owner.phone_number, event.owner.lastOnline);
-      }
-    }
-    async function handleEventRead ({ conversationId, eventId, userId }) {
-      if (conversationId && userId) {
-        if (user.id != userId) {
-          ctx.updateEventReads(conversationId, eventId, userId);
-        }
-      }
-    }
-    async function handleConversationCreated({ conversation }) {
-      const newConversation = await decryptConversations([conversation], socket.chat_private_key, ctx);
-      if (!newConversation[0].hidden) ctx.addConversation(newConversation[0]);
-      ctx.saveConversationToDB(conversation);
-    }
-    const handleTyping = ({userId, conversationId}) => {
-      if (conversationId && userId) {
-        if (userId != socket.chat_user_id) {
-          ctx.setTyping({ conversationId, userId });
-          setTimeout(() => {
-            ctx.unsetTyping({ conversationId, userId });
-          }, 1500);
-        }
-      }
-    };
-    socket.on("events:typing", handleTyping);
-    socket.on("events:read_event", handleEventRead);
-    socket.on("events:event_created", handleEventCreated);
-    socket.on("conversations:created", handleConversationCreated);
     const cleanAuthenticationHooks = ctx.setUpAuthenticationHooks(authenticationCallback);
     const netinfo_unsubscribe = NetInfo.addEventListener((state) => {
       if (state.isConnected) {
@@ -333,15 +378,13 @@ const emitEvents = (recreateKeys = false) => {
         setConnected(false);
       }
     });
+    enableHandlers();
     return () => {
-      socket.off("events:typing", handleTyping);
-      socket.off("events:read_event", handleEventRead);
-      socket.off("events:event_created", handleEventCreated);
-      socket.off("conversations:created", handleConversationCreated);
+      disableHandlers();
       cleanAuthenticationHooks();
       netinfo_unsubscribe();
     };
-  }, [options, retry]);
+  }, [options, retry, users]);
 
   // check authentication error.
   let authError = ctx.getAuthenticationError();
@@ -368,7 +411,7 @@ const emitEvents = (recreateKeys = false) => {
       <>
         {children}
         { showRetryButton ? <Pressable style={styles.errorView} onPress={() => setRetry(!retry)}><Icon style={styles.errorIcon} name="refreshbold" /><Text style={styles.errorText}>
-          Disconnected
+          Disconnected: {authError}
         </Text></Pressable> : null }
       </>
     );
diff --git a/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js b/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
index e356216..525649e 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
@@ -15,7 +15,7 @@ export function authReducer(state, action) {
 }
 
 let authenticationTimeout;
-
+let tries = 0;
 export function createAuthActions(state, dispatch) {
   const socket = getSocket();
 
@@ -23,25 +23,39 @@ export function createAuthActions(state, dispatch) {
     dispatch({ type: "set_authentication_error", payload: { error } });
   }
 
-  function authenticate(options, callback) {
+  function authenticate(options, callback, errorCallback) {
+    const $this = this;
     if (authenticationTimeout) {
       clearTimeout(authenticationTimeout);
     }
 
-    if (typeof options.token !== 'undefined') {
-      socket.emit("users:authenticate", options, function handleAuthSuccess(res) {
+    if (typeof options.userToken !== 'undefined') {
+      socket.emit("users:authenticate", {token: options.userToken}, (res) => {
         if (res && res.success) {
+          tries = 0;
           setAuthInfo(options, res.user);
           setAuthenticationError("");
           if (typeof callback == 'function') callback(res);
         } else {
-          setAuthenticationError("Authentication failed!");
+          if (tries <= 5) {
+            //rconsole.error($this);
+            if (errorCallback) errorCallback("Authentication failed!");
+            //this.authenticate(options, callback, errorCallback);
+            authenticationTimeout = setTimeout(() => {
+              $this.authenticate(options, callback, errorCallback);
+            }, 100 + 150*Math.pow(1.2, tries*2));
+            //wait 150, 216, 311, 447, 644, 928 ms
+            tries++;
+          } else {
+            setAuthenticationError("Authentication failed!");
+          }
         }
       });
     }
   }
 
   function setAuthInfo(options, user) {
+    //console.warn('setAuthInfo', options, user);
     dispatch({ type: "set_authentication_info", payload: { options, user }});
   }
 
@@ -50,7 +64,7 @@ export function createAuthActions(state, dispatch) {
       if (authenticationTimeout) {
         clearTimeout(authenticationTimeout);
       }
-      if (!state.options || !state.options.token) {
+      if (!state.options || !state.options.userToken) {
         setAuthenticationError(error);
       } else {
         authenticationTimeout = setTimeout(function () {
@@ -66,12 +80,11 @@ export function createAuthActions(state, dispatch) {
         clearTimeout(authenticationTimeout);
       }
       setAuthenticationError("Lost connection to the server.");
-      console.warn("Socket disconnected:", error);
-      if (error == 'ping timeout' || error == 'transport close' || error == 'transport error') {
+      //if (error == 'ping timeout' || error == 'transport close' || error == 'transport error') {
         authenticationTimeout = setTimeout(function () {
           authenticate(state.options, callback);
         }, 100);
-      }
+      //}
     };
   }
 
@@ -97,7 +110,7 @@ export function createAuthActions(state, dispatch) {
       return state.authenticationError;
     },
     getToken() {
-      return state.options.token;
+      return state.options.userToken;
     },
     getUser() {
       return state.user;
@@ -109,24 +122,20 @@ export function createAuthActions(state, dispatch) {
       return state.user && state.user.id;
     },
     setUpAuthenticationHooks(callback) {
-      // create handlers.
       const handleSocketError = createSocketErrorHandler(callback);
       const handleRequireAuthentication = createRequireAuthenticationHandler(callback);
       const handleSocketDisconnected = createSocketDisconnectedHandler();
-      socket.on('connect', () => {
+      const handleSocketConnected = () => {};
         
-      });
-      // handle connection error.
       socket.on("error", handleSocketError);
-
-      // handle disconnected.
+      socket.on('connect', handleSocketConnected);
       socket.on("disconnect", handleSocketDisconnected);
-
-      // reply last event on authentication complete.
       socket.on("users:require_authentication", handleRequireAuthentication);
 
       return function cleanAuthenticationHooks() {
         socket.off("error", handleSocketError);
+        socket.off('connect', handleSocketConnected);
+        socket.off("disconnect", handleSocketDisconnected);
         socket.off("users:require_authentication", handleRequireAuthentication);
       };
     },
diff --git a/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js b/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
index 9c7fa48..05e9975 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
@@ -10,6 +10,7 @@ export const ChatInitialState = {
   contacts: [],
   phoneContacts: [],
   settings: {},
+  noBlock: false,
 };
 
 export function ChatReducer(state, action) {
@@ -86,7 +87,9 @@ export function ChatReducer(state, action) {
         conversations[conversationIdx].lastEvent = event;
       }
       if (Array.isArray(conversations[conversationIdx].events)) {
-        conversations[conversationIdx].events.push(event);
+        if (conversations[conversationIdx].events.findIndex(e => e.id == event.id) === -1) {
+          conversations[conversationIdx].events.push(event);
+        }
       }
     }
     return { ...state, conversations };
diff --git a/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js b/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
index e8395c1..557bcb8 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
@@ -1,7 +1,36 @@
-import React from "react";
-import { ChatContext } from "react-native-chat-plugin/ChatContext";
 import { getSocket } from "../utils/SocketIOClient";
-
+const muteUser = (state, userId) => {
+  const newUsers = [...state.users];
+  const userIdx = newUsers.findIndex(u => u.id == userId || u.userId == userId);
+  if (userIdx !== -1 && !newUsers[userIdx].muted_at) {
+    newUsers[userIdx].muted_at = Math.floor(+Date.now()/1000);
+  }
+  return {...state, users: newUsers}
+};
+const unmuteUser = (state, userId) => {
+  const newUsers = [...state.users];
+  const userIdx = newUsers.findIndex(u => u.id == userId || u.userId == userId);
+  if (userIdx !== -1 && newUsers[userIdx].muted_at) {
+    newUsers[userIdx].muted_at = 0;
+  }
+  return {...state, users: newUsers}
+};
+const blockUser = (state, userId) => {
+  const newUsers = [...state.users];
+  const userIdx = newUsers.findIndex(u => u.id == userId || u.userId == userId);
+  if (userIdx !== -1 && !newUsers[userIdx].blocked_at) {
+    newUsers[userIdx].blocked_at = Math.floor(+Date.now()/1000);
+  }
+  return {...state, users: newUsers}
+};
+const unblockUser = (state, userId) => {
+  const newUsers = [...state.users];
+  const userIdx = newUsers.findIndex(u => u.id == userId || u.userId == userId);
+  if (userIdx !== -1 && newUsers[userIdx].blocked_at) {
+    newUsers[userIdx].blocked_at = 0;
+  }
+  return {...state, users: newUsers}
+};
 const addConversations = (state, conversations) => {
   const newConversations = [...state.conversations];
   for (const conversation of conversations) {
@@ -11,7 +40,7 @@ const addConversations = (state, conversations) => {
     } else {
       if (newConversations[conversationIdx].participants) {
         currentParticipants = conversation.participants;
-        delete conversation.participants;
+        //delete conversation.participants;
       }
       if (newConversations[conversationIdx].lastEvent && conversation.lastEvent) {
         if (+ new Date(conversation.lastEvent.time) <  + new Date(newConversations[conversationIdx].lastEvent.time)) {
@@ -21,7 +50,7 @@ const addConversations = (state, conversations) => {
       newConversations[conversationIdx] = {
         ...newConversations[conversationIdx],
         ...conversation,
-        currentParticipants
+        //participants: currentParticipants
       };
     }
   }
@@ -122,12 +151,14 @@ const unsetTyping = (state, conversationId, userId) => {
 export function conversationReducer(state, action) {
   switch(action.type) {
   case "add_user": {
-    // delete conversation by id.
     const user = action.payload.user;
+    const contactName = state.contacts && Object.keys(state.contacts).indexOf(user.username) !== -1 ? state.contacts[user.username] : user.username;
+    user.contactName = contactName;
     const users = [...state.users];
-    const userIdx = state.users.findIndex(u => u.id == user.id);
+    const userIdx = users.findIndex(u => u.id == user.id);
     if (userIdx != -1) {
       users[userIdx] = {
+        ...users[userIdx],
         ...user,
         avatar: users[userIdx].avatar
       };
@@ -136,6 +167,26 @@ export function conversationReducer(state, action) {
     }
     return { ...state, users };
   }
+  case "add_users": {
+    const newUsers = action.payload.users;
+    const users = [...state.users];
+    newUsers.map(user => {
+      //const contactIdx = state.phoneContacts.findIndex(c => c.labels.indexOf(user.username) !== -1);
+      //const contactName = contactIdx !== -1 ? state.phoneContacts[contactIdx].humanValue : (state.user.username !== user.username && user.username != 'Me' ? user.username : "Me");
+      //user.contactName = contactName;
+      const userIdx = users.findIndex(u => u.id == user.id);
+      if (userIdx != -1) {
+        users[userIdx] = {
+          ...users[userIdx],
+          ...user,
+          avatar: users[userIdx].avatar
+        };
+      } else {
+        users.push(user);
+      }
+    });
+    return { ...state, users };
+  }
   case "set_last_online": {
     const usersLastOnline = action.payload.users;
     const users = [...state.users];
@@ -241,6 +292,22 @@ export function conversationReducer(state, action) {
   case "unset_typing": {
     return unsetTyping(state, action.payload.conversationId, action.payload.userId);
   }
+
+  case "block_user": {
+    return blockUser(state, action.payload.userId);
+  }
+
+  case "unblock_user": {
+    return unblockUser(state, action.payload.userId);
+  }
+
+  case "mute_user": {
+    return muteUser(state, action.payload.userId);
+  }
+
+  case "unmute_user": {
+    return unmuteUser(state, action.payload.userId);
+  }
   }
   return state;
 }
@@ -308,15 +375,17 @@ export function createConversationActions(state, dispatch) {
       const user = state.user;
       if (!conversation) return "";
       if (typeof conversation.participants !== "undefined" && (conversation.avatar == "" || !conversation.avatar)) {
+        
         const notOwner = conversation.participants.filter(f=>f.id != user.id)
         if (!notOwner[0]) {
           return this.getCurrentUser().avatar;
         }
-        const notOwnerIdx = state.users.findIndex(u=>u.id == notOwner[0].id);
-        if (notOwnerIdx !== -1) {
-          return state.users[notOwnerIdx].avatar;
+        const notOwnerIdxs = notOwner.map(u => String(u.id));
+        const notOwnerIdx = state.users.map((u,i)=>notOwnerIdxs.indexOf(String(u.id)) !== -1 ? i : '').filter(String);
+        if (notOwnerIdx.length) {
+          return notOwnerIdx.map(idx => state.users[idx].avatar);
         } 
-        return notOwner[0] ? notOwner[0].avatar : "";
+        return "";
       } return conversation.avatar;
     },
     getChatname(conversation) {
@@ -324,8 +393,9 @@ export function createConversationActions(state, dispatch) {
       if (!conversation) return "";
       if (typeof conversation.participants !== "undefined" && (conversation.name == "" || !conversation.name)) {
         const notOwner = conversation.participants.filter(f=>f.id != user.id)
-        const name = notOwner[0] ? this.getContactName(notOwner[0].username) : "Me";
-        return name;
+        if (!notOwner.length) return "Me";
+        const names = notOwner.map(u => this.getContactName(u.username));
+        return (names.length > 1 ? "Group chat ("+(names.length+1)+" users)" : names[0]);
       } return conversation.name;
     },
     getContactName(phone_number) {
@@ -333,14 +403,31 @@ export function createConversationActions(state, dispatch) {
       return contactIdx !== -1 ? state.phoneContacts[contactIdx].humanValue : (state.user.username !== phone_number && phone_number != 'Me' ? phone_number : "Me");
     },
     getUsernameByUserId(userId) {
-
       const users = state.users;
-      const userIdx = state.users.findIndex(u => u.userId == userId);
+      const userIdx = state.users.findIndex(u => u.userId == userId || u.id == userId);
       return userIdx !== -1 ? this.getContactName(users[userIdx].username) : `Me`; 
     },
+    isUserBlocked(userId) {
+      if (state.noBlock) return false;
+      if (!userId) return false;
+      const users = state.users;
+      const userIdx = state.users.findIndex(u => u.userId == userId || u.id == userId);
+      return userIdx !== -1 ? users[userIdx].blocked_at > 0: false; 
+    },
+    isUserMuted(userId) {
+      if (!userId) return false;
+      const users = state.users;
+      const userIdx = state.users.findIndex(u => u.userId == userId || u.id == userId);
+      return userIdx !== -1 ? users[userIdx].muted_at : false; 
+    },
     getUsers() {
       return state.users || [];
     },
+    getUserById(userId) {
+      const users = state.users;
+      const userIdx = state.users.findIndex(u => u.userId == userId || u.id == userId);
+      return userIdx !== -1 ? users[userIdx] : false; 
+    },
     getCalls() {
       return state.calls ? state.calls.sort((a,b)=>{
         if (a.created_at && b.created_at) {
@@ -349,7 +436,6 @@ export function createConversationActions(state, dispatch) {
       }) : [];
     },
     getConversations() {
-      
       sortedConversations = state.conversations.sort((a,b)=>{
         if (a.pinned && !b.pinned) return false;
         if (a.lastEvent && b.lastEvent) {
@@ -362,6 +448,9 @@ export function createConversationActions(state, dispatch) {
       });
       return sortedConversations || [];
     },
+    getConversationById(id) {
+      return state.conversations[state.conversations.findIndex(c => c.id == id)] || null;
+    },
     setConversations(conversations) {
       if (Array.isArray(conversations)) {
         dispatch({ type: "add_conversations", payload: { conversations }});
@@ -370,6 +459,9 @@ export function createConversationActions(state, dispatch) {
     addUser(user) {
       dispatch({ type: "add_user", payload: { user }});
     },
+    addUsers(users) {
+      dispatch({ type: "add_users", payload: { users }});
+    },
     addConversation(conversation) {
       dispatch({ type: "add_conversation", payload: { conversation }});
     },
diff --git a/node_modules/react-native-chat-plugin/ChatContext/index.js b/node_modules/react-native-chat-plugin/ChatContext/index.js
index 7752e79..d8471c0 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/index.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/index.js
@@ -19,7 +19,7 @@ const reducer = combineReducers(
 );
 
 export function ChatContextProvider({options,children,socketIoUrl, getDB, icon, contacts}) {
-  const [state, dispatch] = React.useReducer(reducer, ChatInitialState);
+  const [state, dispatch] = React.useReducer(reducer, {...ChatInitialState,options});
   const removeFolderFromDisk = React.useCallback((type) => {
     return new Promise((resolve, reject) => {
       //TODO: remove folder from disk
@@ -236,7 +236,7 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
     return new Promise((resolve, reject) => {
       return getDB().then((db)=> {
         db.executeSql(
-          "SELECT users.userId as id, users.created_at, users.avatarFileId, users.avatarUrl, users.username, users.phone_number, users.seen_at as lastOnline,files.path FROM users LEFT JOIN files ON users.avatarFileId = files.id ORDER BY users.created_at DESC"
+          "SELECT users.userId as id, users.muted_at, users.deleted_at, users.blocked_at, users.created_at, users.avatarFileId, users.avatarUrl, users.username, users.phone_number, users.seen_at as lastOnline,files.path FROM users LEFT JOIN files ON users.avatarFileId = files.id ORDER BY users.created_at DESC"
         ).then(([results])=> {
           resolve(results.rows.length > 0 ? results.rows : false);
         });
@@ -247,13 +247,12 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
     return new Promise((resolve, reject) => {
       return getDB().then((db)=> {
         db.executeSql(
-          `SELECT conversations.*, users.*, messages.*, conversations.created_at as createdAt, conversations.group_id as groupId, messages.created_at as eventCreatedAt, messages.author_id as eventUserId, messages.event_id as eventId, messages.id as localId   FROM conversations
+          `SELECT conversations.*, users.*, messages.*, conversations.avatar as group_avatar, conversations.created_at as createdAt, conversations.group_id as groupId, messages.created_at as eventCreatedAt, messages.author_id as eventUserId, messages.event_id as eventId, messages.id as localId   FROM conversations
           LEFT JOIN participants ON conversations.group_id = participants.group_id
           LEFT JOIN users ON participants.user_id = users.userId
           LEFT JOIN messages ON conversations.group_id = messages.group_id
           ORDER BY messages.created_at ASC`
         ).then(([results])=> {
-          
           resolve(results.rows.length > 0 ? results.rows : false);
         });
       })
@@ -277,7 +276,7 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
     return new Promise((resolve, reject) => {
       return getDB().then((db)=> {
         db.executeSql(
-          "SELECT * FROM messages WHERE group_id = ? ORDER BY created_at DESC",
+          "SELECT * FROM messages ORDER BY created_at DESC",
           [conversationId]
         ).then(([results])=> {
           if (results.rows.length > 0) {
@@ -331,7 +330,7 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
         resolve("");
         return;
       }
-      const path = filetype + "/" + SHA512(url);
+      const path = filetype + "/" + SHA512(url) + ".jpg";
       const dirExists = await RNFS.exists(RNFS.DocumentDirectoryPath + '/' + filetype);
       if (!dirExists) {
         await RNFS.mkdir(RNFS.DocumentDirectoryPath + '/' + filetype);
@@ -412,6 +411,50 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
       });
     })
   },[]);
+  const muteUser = React.useCallback((userId) => {
+    dispatch({ type: "mute_user", payload: { userId }});
+    return new Promise((resolve, reject) => {
+      getDB().then(async (db)=> {
+        await db.executeSql(
+          "UPDATE users SET muted_at=? WHERE userId=?",
+          [+new Date() / 1000, userId]
+        );
+      })
+    });
+  },[]);
+  const unmuteUser = React.useCallback((userId) => {
+    dispatch({ type: "unmute_user", payload: { userId }});
+    return new Promise((resolve, reject) => {
+      getDB().then(async (db)=> {
+        await db.executeSql(
+          "UPDATE users SET muted_at=? WHERE userId=?",
+          [0, userId]
+        );
+      })
+    });
+  },[]);
+  const blockUser = React.useCallback((userId) => {
+    dispatch({ type: "block_user", payload: { userId }});
+    return new Promise((resolve, reject) => {
+      getDB().then(async (db)=> {
+        await db.executeSql(
+          "UPDATE users SET blocked_at=? WHERE userId=?",
+          [Math.floor(+new Date() / 1000), userId]
+        );
+      })
+    });
+  },[]);
+  const unblockUser = React.useCallback((userId) => {
+    dispatch({ type: "unblock_user", payload: { userId }});
+    return new Promise((resolve, reject) => {
+      getDB().then(async (db)=> {
+        await db.executeSql(
+          "UPDATE users SET blocked_at=? WHERE userId=?",
+          [0, userId]
+        );
+      })
+    });
+  },[]);
   const saveUserToDB = React.useCallback((userId, avatarUrl, username, phone_number, seen_at) => {
     return new Promise((resolve, reject) => {
       getDB().then(async (db)=> {
@@ -422,10 +465,17 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
         if (existingUser[0].rows.length > 0) {
           const avatarFileId = avatarUrl !== null ? await saveFile(avatarUrl,'avatar',userId) : existingUser[0].rows.item(0).avatarFileId;
           const avatar = avatarUrl !== null ? avatarUrl : existingUser[0].rows.item(0).avatarUrl;
-          const update = await db.executeSql(
-            "UPDATE users SET username=?, avatarUrl=?, avatarFileId=?, phone_number=?, seen_at=? WHERE userId=?",
-            [ username, avatarUrl, avatarFileId, phone_number, new Date(seen_at) / 1000, userId]
-          );
+          if (seen_at > 0) { 
+            const update = await db.executeSql(
+              "UPDATE users SET username=?, avatarUrl=?, avatarFileId=?, phone_number=?, seen_at=? WHERE userId=?",
+              [ username, avatarUrl, avatarFileId, phone_number, new Date(seen_at) / 1000, userId]
+            );
+          } else {
+            const update = await db.executeSql(
+              "UPDATE users SET username=?, avatarUrl=?, avatarFileId=?, phone_number=? WHERE userId=?",
+              [ username, avatarUrl, avatarFileId, phone_number, userId]
+            );
+          }
         } else {
           const avatarFileId = avatarUrl !== null ? await saveFile(avatarUrl,'avatar',userId) : 0;
           return await db.executeSql(
@@ -441,8 +491,8 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
     //const conversation = conversations[conversationIdx];
     return getDB().then((db)=> {
       return db.executeSql(
-        "INSERT OR IGNORE INTO messages(`group_id`,`text`,`author_id`, `event_id`, `type`, created_at, is_delivered) VALUES (?, ?, ?, ?, ?, ?, ?)",
-        [conversationId, contents, author, event_id, type, time > 0 ? Math.floor(new Date(time) / 1000) : Math.floor(Date.now() / 1000), delivered_at ? Math.floor(Date.now() / 1000) : 0]
+        "INSERT OR IGNORE INTO messages(`group_id`,`text`,`author_id`, `event_id`, `type`, `created_at`, `is_delivered`) VALUES (?, ?, ?, ?, ?, ?, ?)",
+        [conversationId, contents, author, event_id, type, time ? Math.floor(+new Date(time) / 1000) : Math.floor(+Date.now() / 1000), delivered_at ? Math.floor(Date.now() / 1000) : 0]
       ).then(([results])=> {
         return results.insertId;
       });
@@ -451,14 +501,16 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
   const saveConversationToDB = React.useCallback((conversation) => {
     getDB().then((db)=> {
       db.executeSql(
-        "INSERT OR IGNORE INTO conversations(`group_id`,`group_key`,`name`,`created_by`,`created_at`) VALUES (?, ?, ?, ?, ?)",
-        [conversation.id, "", conversation.name, conversation.createdBy, new Date(conversation.time) / 1000 ]
+        "INSERT OR IGNORE INTO conversations(`group_id`,`group_key`,`name`, `avatar`, `created_by`,`created_at`) VALUES (?, ?, ?, ?, ?, ?)",
+        [conversation.id, "", conversation.name, conversation.avatar, conversation.createdBy, new Date(conversation.time) / 1000 ]
       ).then(([results])=> {
-        if (conversation.participants) conversation.participants.map(p =>  
-          db.executeSql(
-            "INSERT OR IGNORE INTO participants(`group_id`,`user_id`, `created_at`) VALUES (?, ?, ?)",
-            [conversation.id, p.id, Math.floor(Date.now() / 1000)]
-          )
+        if (conversation.participants) conversation.participants.map(p => {
+            saveUserToDB(p.id, p.avatar, p.name, p.username, 0)
+            return db.executeSql(
+              "INSERT OR IGNORE INTO participants(`group_id`,`user_id`, `created_at`) VALUES (?, ?, ?)",
+              [conversation.id, p.id, Math.floor(+Date.now() / 1000)]
+            )
+          }
         );
         return results;
       });
@@ -519,6 +571,10 @@ export function ChatContextProvider({options,children,socketIoUrl, getDB, icon,
         getGroupsFromDB,
         deleteCall,
         markMessage,
+        blockUser,
+        unblockUser,
+        muteUser,
+        unmuteUser,
       });
     },
     [state]
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js b/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
index 2d8eeea..e988f42 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
@@ -11,6 +11,8 @@ import {launchCamera, launchImageLibrary} from "react-native-image-picker";
 
 import WebView from "react-native-webview";
 import uuid from 'uuid';
+import { responsiveWidth } from "react-native-responsive-dimensions";
+import APIService from "../../../src/service/APIService";
 //import Recording from "react-native-recording";
 
 const sendButton = require("../images/sendbtn.png");
@@ -35,7 +37,7 @@ const styles = StyleSheet.create({
     paddingTop:13,
     margin: 10,
     marginLeft: 25,
-    marginRight: 25,
+    marginRight: 10,
     borderRadius: 8,
     paddingLeft: 40,
   },
@@ -47,7 +49,7 @@ const styles = StyleSheet.create({
     paddingRight: 10,
     height: "50%",
     margin: 10,
-    borderRadius: 50
+    borderRadius: 50,
   },
   btnText: {
     textAlign: "center",
@@ -56,11 +58,13 @@ const styles = StyleSheet.create({
   btnImage: {
     alignContent: "center",
     justifyContent: "center",
+    //backgroundColor: "red",
+    width: responsiveWidth(15)
   },
   btnImageStyles: {
     width: 38,
     height: 38,
-    right: 15,
+    //right: 15,
     top:-12,
   },
   btnIcon: {
@@ -157,9 +161,9 @@ export default function ChatForm({ conversation }) {
   }
   const sendMessage = React.useCallback(async (contents) => {
     const socket = getSocket();
+    setMessage("");
     const encrypted = await encryptMessage(contents, global.encryptionKeys.public_key, global.encryptionKeys.private_key);
     const messageToSend = encrypted.nonce + "|" + global.encryptionKeys.public_key + "|" + encrypted.encryptedMessage;
-    setMessage("");
     const localMsg = await ctx.saveMessageToDB(conversation.id, contents, user.id, "MESSAGE", uuidv4(), 0, false);
     const newMessage = {
       id: String(localMsg),
@@ -170,29 +174,38 @@ export default function ChatForm({ conversation }) {
       time: +Date.now(), 
       text: contents,
       is_delivered: false,
+      encrypted: true,
     };
     ctx.addEvent(newMessage);
-    setTimeout(()=>{
-      socket.emit("events:new_message", { conversationId: conversation.id, message: messageToSend, nonce: localMsg }, ({ success, error, event, nonce }) => {
-        if (!success && error) {
-          if (tries >= maxRetries) {
-            Alert.alert("Error", "Failed to send message");
-          } else {
-            setTries(tries + 1);
-            setTimeout(()=>{
-              sendMessage(contents);
-            }, 1000 * (1+tries * 2));
-          }
-        } else if (event) {
-          //console.warn('mark as read?', localMsg);
-          ctx.updateEvent(conversation.id, localMsg, {...event, text:contents, is_delivered:true})
-          ctx.updateMessageEvent(localMsg, event)
+    socket.emit("events:new_message", { conversationId: conversation.id, message: messageToSend, nonce: localMsg }, ({ success, error, event, nonce }) => {
+      if (!success && error) {
+        if (tries >= maxRetries) {
+          Alert.alert("Error", "Failed to send message");
+        } else {
+          setTries(tries + 1);
+          setTimeout(()=>{
+            sendMessage(contents);
+          }, 1000 * (1+tries * 2));
         }
-      });
-    },100)
+      } else if (event) {
+        const others = conversation.participants.map(p => p.id).filter(p => String(p) !== String(socket.chat_user_id));
+        APIService('users/pushmessage/',{
+          users: others,
+          message: contents,
+          extra: {
+            conversationId: conversation.id,
+            author: user.id,
+          }
+        });
+        ctx.updateEvent(conversation.id, localMsg, {...event, text:contents, is_delivered:true, encrypted: true})
+        ctx.updateMessageEvent(localMsg, event)
+      }
+    });
   },[]);
   const submit = React.useCallback(() => {
     if (message) {
+      sendMessage(message);
+      /*
       ctx.getDB().then((db)=> {
         db.executeSql(
           "SELECT * FROM conversations WHERE group_id = ?",
@@ -212,7 +225,7 @@ export default function ChatForm({ conversation }) {
       }).catch((e)=>{
         console.warn(e);
       });
-      
+      */
       Keyboard.dismiss();
     }
   },[message, ctx]);
@@ -279,6 +292,7 @@ export default function ChatForm({ conversation }) {
     <View style={styles.container}>
       <Image source={messageIcon} style={styles.messageIcon} />
       <TextInput
+        textContentType="none"
         textAlignVertical={"top"}
         numberOfLines={5}
         multiline={false}
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js b/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
index 2419a3d..a03aad6 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
@@ -1,6 +1,7 @@
 import React from "react";
-import { View, StyleSheet, Alert, KeyboardAvoidingView, ImageBackground, Platform, Text } from "react-native";
-import PropTypes from "prop-types";
+import Modal from 'react-native-modal';
+import { View, StyleSheet, Alert, KeyboardAvoidingView, Image, ImageBackground, Platform, Text, ScrollView, FlatList, Dimensions } from "react-native";
+import PropTypes, { string } from "prop-types";
 import Header from "../Components/Header";
 import ChatForm from "./ChatForm";
 import { getSocket } from "../utils/SocketIOClient";
@@ -18,6 +19,11 @@ import Pressable from "react-native/Libraries/Components/Pressable/Pressable";
 import Clipboard from "@react-native-clipboard/clipboard";
 import {captureRef} from "react-native-view-shot";
 import Share from "react-native-share";
+import SearchResultComponent from "react-native-chat-plugin/SearchContactsScreen/SearchResultComponent";
+import APIService from "../../../src/service/APIService";
+import { responsiveFontSize, responsiveHeight, responsiveWidth } from "react-native-responsive-dimensions";
+import { UserContext } from "../../../src/context/UserContext";
+import moment from "moment";
 
 const styles = StyleSheet.create({
   container: {
@@ -37,6 +43,40 @@ const styles = StyleSheet.create({
     width: "100%",
     height: "100%"
   },
+  modalClose: {
+    fontSize: responsiveWidth(10),
+    color: "black",
+    paddingVertical: responsiveWidth(2),
+    alignSelf: "flex-end",
+    paddingHorizontal: responsiveWidth(4),
+  },
+  modalPlus: {
+    fontSize: responsiveWidth(8),
+    color: "rgb(110,110,110)",
+    
+    
+  },
+  modalPlusButton: {
+    paddingHorizontal: responsiveWidth(3),
+    paddingVertical: responsiveWidth(3),
+    zIndex: 999,
+    left: responsiveWidth(2),
+    alignSelf: "flex-start",
+  },
+  modalPlusText: {
+    textAlign: "center",
+    fontSize: responsiveWidth(3),
+  },
+
+  modalContainer: {
+    flex: 1,
+    backgroundColor: "white",
+    marginTop: responsiveWidth(5),
+  },
+  modalButtons: {
+    flexDirection: "row",
+    justifyContent:"space-between",
+  },
   buttons: {
     marginVertical: 10,
     flexDirection: "row",
@@ -108,6 +148,83 @@ const styles = StyleSheet.create({
     transform: [
       {rotateY: "180deg"}
     ]
+  },
+  modalHeadline: {
+    backgroundColor: "white",
+    justifyContent: "center",
+    alignContent: "center",
+    textAlign: "center",
+  },
+  modalHeadlineText: {
+    backgroundColor: "white",
+    justifyContent: "center",
+    alignContent: "center",
+    textAlign: "center",
+    fontSize: 24,
+    fontWeight: "200",
+    marginVertical: responsiveWidth(3)
+  },
+  profileAvatar: {
+    width: responsiveWidth(30),
+    height: responsiveWidth(30),
+    borderColor: "rgb(242,142,62)",
+    borderWidth: 1,
+    borderRadius: responsiveWidth(20),
+    marginLeft: responsiveWidth(3),
+    marginVertical: responsiveWidth(5),
+  },
+  profileName: {
+    fontSize: responsiveFontSize(5),
+    fontWeight: "200",
+    marginHorizontal: responsiveWidth(3),
+  },
+  profileUsername: {
+    fontSize: responsiveFontSize(3),
+    fontWeight: "400",
+    marginHorizontal: responsiveWidth(3),
+    marginVertical: responsiveWidth(1),
+  },
+  profileLastOnline: {
+    fontSize: responsiveFontSize(1.5),
+    fontWeight: "400",
+    marginHorizontal: responsiveWidth(3),
+  },
+  profileMuteIcon: {
+    alignSelf: "center",
+    top: 3,
+    fontSize: responsiveFontSize(2),
+    color: "rgb(100,100,100)",
+    marginRight: responsiveWidth(3),
+  },
+  profilePhone: {
+    fontSize: responsiveFontSize(3.25),
+    fontWeight: "300",
+    alignSelf: "center",
+    marginHorizontal: responsiveWidth(3),
+  },
+  profileAction: {
+    padding: responsiveWidth(3),
+    backgroundColor: "rgb(128,167,120)",
+    borderRadius: 5,
+    marginHorizontal: responsiveWidth(3),
+    marginVertical: responsiveWidth(2),
+  },
+  profileImportantAction: {
+    padding: responsiveWidth(3),
+    backgroundColor: "rgb(214,73,47)",
+    borderRadius: 5,
+    marginHorizontal: responsiveWidth(3),
+    marginVertical: responsiveWidth(2),
+  },
+  profileActionText: {
+    fontSize: responsiveWidth(4),
+    color: "white",    
+  },
+  profileBox: {
+    flexDirection: "row",
+  },
+  namesBox: {
+    alignSelf: "center",
   }
 });
 
@@ -127,21 +244,56 @@ const shareImage = async (viewRef) => {
 };
 
 
-
+//{"users":[1], "message": "hey! hello world!", "callUUID": "76cf0f19-6783-43db-8f3f-0145fbd000e1"}
 const chatWallpaper = require("../images/chat_background.png");
 export default function ChatScreen({ navigation, route }) {
 
-  const conversation = route?.params?.conversation;
+  const ctx = React.useContext(ChatContext);
+  const {authData} = React.useContext(UserContext);
+
+  const userId = ctx.getUserId();
+  const conversationId = route?.params?.conversation;
+  const conversationObject = route?.params?.conversationObject;
+  
+  const conversationFromState = ctx.getConversationById(conversationId);
+  const conversation = conversationObject && !conversationFromState ? conversationObject : conversationFromState;
+  const others = conversation && conversation.participants.map(p => p.id).filter(p => String(p) !== String(userId));
+  const chatName = ctx.getChatname(conversation);
+  const lastOnline = ctx.getChatLastOnline(conversation);
+  const users = ctx.getUsers();
+  const contacts = ctx.getPhoneContacts();
+  moment.locale('en')
+  const lastOnlineHumanized = moment(lastOnline).fromNow();
+  const voipCall = (conversation) => {
+    if (others) {
+      APIService('users/voipcall/', {
+        users: others,
+        callUUID: conversation.id,
+        message: "Wevive Call",
+      });
+      APIService('users/pushmessage/', {
+        users: others,
+        callUUID: conversation.id,
+        message: "",
+        extra: {
+          'callUUID': conversation.id,
+          'username': authData.username,
+          'avatarURL': authData.avatarHosted
+        }
+      });
+    }
+  };
   if (!conversation) {
-    navigation.goBack();
+    //navigation.goBack();
     return null;
   }
   const insets = useSafeArea();
   const [selectedEvent, setSelectedEvent] = React.useState(false);
-  const [showMenu, setShowMenu] = React.useState(false);
   const [reply, setReply] = React.useState(false);
   const [lastpage, setLastPage] = React.useState(false);
-  const ctx = React.useContext(ChatContext);
+  const [visible, setVisible] = React.useState(false);
+  const [selectedContact, setSelectedContact] = React.useState(false);
+  const selectedUser = ctx.getUserById(selectedContact);
   const settings = ctx.getSettings();
   const events = conversation.events || ctx.getEvents(conversation.id);
   const parseEvents = React.useCallback((events)=> {
@@ -167,6 +319,13 @@ export default function ChatScreen({ navigation, route }) {
         if (text === "Forward") {
           navigation.navigate('ContactsScreen', {event});
         }
+        if (text === "Report") {
+          APIService('messages/report/',{event, conversation});
+          Alert.prompt("Message reported", "Would you like to block the user?", [
+            {text: 'No', onPress: () => {}},
+            {text: 'Yes', onPress: () => Alert.alert('User blocked'), style:"destructive"},
+          ], 'default');
+        }
         if (text === "Save") {
           setTimeout(() => {
             shareImage(viewRef);
@@ -184,13 +343,22 @@ export default function ChatScreen({ navigation, route }) {
     const username = ctx.getUserId();
     const author = event?.owner?.id;
     const isOwn = author == username;
+    let top = tapEvent.nativeEvent.pageY - 200;
+    if (top < responsiveHeight(10))  {
+      top = responsiveHeight(10);
+    } else {
+      if (top > responsiveHeight(38)) {
+        top = responsiveHeight(38);
+      }
+    }
     return (
-      <View style={{...(isOwn ? styles.ownMenuBox : styles.menuBox), top: tapEvent.nativeEvent.pageY - 170}}>
+      <View style={{...(isOwn ? styles.ownMenuBox : styles.menuBox), top: top}}>
         <MenuButton style={styles.menuButton} event={event} text={"Star"} Icon={Icon} iconName={"star-icon"} size={15} setSelectedEvent={setSelectedEvent} />
         {!conversation.group && <MenuButton style={styles.menuButton} event={event} text={"Reply"} Icon={Icon} iconName={"reply-icon"} size={12} setSelectedEvent={setSelectedEvent} />}
         <MenuButton style={styles.menuButton} event={event} text={"Forward"} Icon={Icon} iconName={"reply-icon"} size={12} setSelectedEvent={setSelectedEvent} />
         <MenuButton style={styles.menuButton} event={event} text={"Copy"} Icon={Icon} iconName={"copy-icon"} size={15} setSelectedEvent={setSelectedEvent} />
-        <MenuButton viewRef={viewRef} style={styles.lastMenuButton} event={event} text={"Save"} Icon={Icon} iconName={"save-download-icon"} size={15} setSelectedEvent={setSelectedEvent} />
+        <MenuButton viewRef={viewRef} style={styles.menuButton} event={event} text={"Save"} Icon={Icon} iconName={"save-download-icon"} size={15} setSelectedEvent={setSelectedEvent} />
+        <MenuButton style={styles.lastMenuButton} event={event} text={"Report"} Icon={Icon} iconName={"alert-triangle"} size={12} setSelectedEvent={setSelectedEvent} />
       </View>
     );
   }
@@ -202,6 +370,7 @@ export default function ChatScreen({ navigation, route }) {
       socket.emit("events:fetch", { conversationId: conversation.id, skip: 0 }, async function ({ events }) {
         const decryptedEvents = await decryptEventsBasic(conversation.id, events, socket.chat_private_key, ctx);
         const parsedEvents = await parseEvents(decryptedEvents);
+        parsedEvents.filter((e)=>e.owner && ctx.isUserBlocked(e.owner.id));
         ctx.setEvents({ conversationId: conversation.id, events: parsedEvents });
         parsedEvents.map(e => {
           ctx.saveMessageToDB(conversation.id, e.text, e.owner.id, e.type, e.id, e.time)
@@ -235,7 +404,7 @@ export default function ChatScreen({ navigation, route }) {
   }, []);
   function fetchMoreMessages() {
     if (lastpage) return;
-    const socket = getSocket();
+    
     socket.emit("events:fetch", { conversationId: conversation.id, skip: events.length }, async function (update) {
       if (!update.events.length) setLastPage(true);
       const decryptedEvents = await decryptEventsBasic(conversation.id, update.events, socket.chat_private_key, ctx);
@@ -246,34 +415,184 @@ export default function ChatScreen({ navigation, route }) {
       })
     });
   }
+  const socket = getSocket();
   const Icon = ctx.icon;
   const buttons = !conversation.group ? <View style={styles.buttons}>
     <Pressable style={styles.button} onPress={()=>{
+      voipCall(conversation);
       navigation.navigate("VideoCalls",{callId:conversation.id, video:false});
     }}>
       <Icon name="medium-call-icon" style={styles.callIcon} />
     </Pressable>
     <Pressable style={styles.button} onPress={()=>{
+      voipCall(conversation);
       navigation.navigate("VideoCalls",{callId:conversation.id, video:true});
     }}>
       <Icon name="medium-video-icon" style={styles.videoCallIcon} />
     </Pressable>
   </View> : null;
+  
   let offset = 30 + insets.top;
+  const setModalVisible = () => {
+    setVisible(true);
+  };
+  const setModalInvisible = () => {
+    setVisible(false);
+  };
+  const addParticipants = () => {
+    setVisible(false);
+    navigation.navigate('SearchContactsScreen',{conversationId:conversation.id});
+  }
+  const deselectContact = () => {
+    setSelectedContact(false);
+  };
+  const  onPress = () => {
+    //onPress
+  }
+  const isGroupChat = () => {
+    return others.length > 1 || conversation.name;
+  }
+  const kickContact = () => {
+    Alert.prompt("Confirm action", "Would you like to kick "+selectedUser.username+"?", [
+      {text: 'No', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }},
+      {text: 'Yes', onPress: () => {
+        socket.emit("conversations:block",{participantsIds:[String(selectedUser.id)], conversationId: conversation.id}, ({ success, conversation, error }) =>  {
+          if (success && conversation) {
+            ctx.addConversation(conversation);
+          }
+        });
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }, style:"destructive"},
+    ], 'default');
+  }
+  const muteContact = () => {
+    const action = !selectedUser.muted_at ? "mute" : "unmute";
+    Alert.prompt("Confirm action", "Would you like to "+action+" "+selectedUser.name+"?", [
+      {text: 'No', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }},
+      {text: 'Yes', onPress: () => {
+        !selectedUser.muted_at ? ctx.muteUser(selectedUser.id) : ctx.unmuteUser(selectedUser.id);
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }, style:"destructive"},
+    ], 'default');
+  }
+  const blockContact = () => {
+    const action = !selectedUser.blocked_at ? "block" : "unblock";
+    Alert.prompt("Confirm action", "Would you like to "+action+" "+selectedUser.name+"?", [
+      {text: 'No', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }},
+      {text: 'Yes', onPress: () => {
+        !selectedUser.blocked_at ? ctx.blockUser(selectedUser.id) : ctx.unblockUser(selectedUser.id);
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }, style:"destructive"},
+    ], 'default');
+    
+  }
+  const reportContact = () => {
+    Alert.prompt("Confirm action", "Would you like to report "+selectedUser.name+"?", [
+      {text: 'No', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }},
+      {text: 'Yes', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }, style:"destructive"},
+    ], 'default');
+  }
+  const deleteContact = () => {
+    Alert.prompt("Confirm action", "Would you like to delete "+selectedUser.name+" from your contact list?", [
+      {text: 'No', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }},
+      {text: 'Yes', onPress: () => {
+        setSelectedContact(false);
+        if (isGroupChat()) {
+          setTimeout(() => {
+            setVisible(true);
+          },600);
+        }
+      }, style:"destructive"},
+    ], 'default');
+  }
+  
+  const onContactPress = (item, noTimeout) => {
+    //console.error(item);
+    return () => {
+      if (!noTimeout) {
+        setTimeout(() => {
+          setSelectedContact(item.id);
+        },600);
+        setVisible(false);
+      } else {
+        setSelectedContact(item.id);
+      }
+    }
+  }
+  const onHeaderPress = isGroupChat() ? setModalVisible : onContactPress(conversation.participants[conversation.participants.findIndex(p => p.id == others[0])],true)
+  const contactName = ctx.getContactName(selectedUser.phone_number);
   return (
     <>
       <View style={styles.container}>
         <Header
           right={buttons}
           conversation={conversation}
-          title={ctx.getChatname(conversation)}
+          title={chatName}
           avatar={ctx.getChatAvatar(conversation)}
-          lastOnline={ctx.getChatLastOnline(conversation)}
+          lastOnline={lastOnline}
+          onPress={onHeaderPress}
         />
         <View style={styles.inner}>
           <View style={styles.list}>
             <ImageBackground source={chatWallpaper} style={styles.wallpaper}>
-              <MessageList events={events} onEndReached={() => {
+              <MessageList conversation={conversation} events={events} onEndReached={() => {
                 if (events.length >= 20) {
                   fetchMoreMessages();
                 }
@@ -287,6 +606,63 @@ export default function ChatScreen({ navigation, route }) {
             </ImageBackground>
           </View>
         </View>
+        <Modal isVisible={visible} animationOut={"slideOutLeft"}>
+          <View style={styles.modalContainer}>
+            <View style={styles.modalButtons}>
+            <Pressable onPress={addParticipants} style={styles.modalPlusButton}>
+              <Icon name="add" style={styles.modalPlus} />
+              <Text style={styles.modalPlusText}>Add</Text>
+            </Pressable>
+            <Pressable onPress={setModalInvisible}><Icon name="close" style={styles.modalClose} /></Pressable>
+            </View>
+            <View style={styles.modalHeadline}>
+            </View>
+            <FlatList
+              style={styles.container}
+              data={conversation.participants}
+              renderItem={({item}) => <SearchResultComponent contacts={conversation.participants} contact={item} onPress={onContactPress(item)} notSelectable  />}
+            />
+          </View>
+        </Modal>
+        <Modal isVisible={selectedContact !== false} animationIn={"slideInRight"} animationOut={"slideOutUp"}>
+          <View style={styles.modalContainer}>
+            <Pressable onPress={deselectContact}><Icon name="close" style={styles.modalClose} /></Pressable>
+            <View style={styles.modalHeadline}>
+            </View>
+            <View style={styles.profileBox}>
+              <Text style={styles.profileName}>{contactName}</Text>
+              {selectedUser.muted_at > 0 && <Icon name="mute-icon" style={styles.profileMuteIcon}/>}
+              {selectedUser.blocked_at > 0 && <Icon name="trash" style={styles.profileMuteIcon}/>}
+            </View>
+            <View style={styles.profileBox}>
+              <Image source={{uri:selectedUser.avatar}} style={styles.profileAvatar} />
+              <View style={styles.namesBox}>
+                <Text style={styles.profilePhone}>{selectedUser.name || selectedUser.username}</Text>
+                <Text style={styles.profileUsername}>{selectedUser.phone_number}</Text>
+                <Text style={styles.profileLastOnline}>{moment(selectedUser.lastOnline).fromNow()}</Text>
+              </View>
+            </View>
+            {String(selectedUser.id) !== String(authData.id) && selectedContact !== false &&
+            <>
+            {isGroupChat() == true &&
+            <Pressable style={styles.profileAction} onPress={kickContact}>
+              {!selectedUser.muted_at && <Text style={styles.profileActionText}>Kick Contact</Text>}
+            </Pressable>
+            }
+            <Pressable style={styles.profileAction} onPress={muteContact}>
+            {selectedUser.muted_at > 0 && <Text style={styles.profileActionText}>Unmute Contact</Text>}
+            {!selectedUser.muted_at && <Text style={styles.profileActionText}>Mute Contact</Text>}
+            </Pressable>
+            <Pressable style={styles.profileImportantAction} onPress={blockContact}>
+              {selectedUser.blocked_at > 0 && <Text style={styles.profileActionText}>Unblock Contact</Text>}
+              {!selectedUser.blocked_at && <Text style={styles.profileActionText}>Block Contact</Text>}
+            </Pressable>
+            <Pressable style={styles.profileImportantAction} onPress={reportContact}>
+              <Text style={styles.profileActionText}>Report Contact</Text>
+            </Pressable>
+            </>}
+          </View>
+        </Modal>
         {selectedEvent && Menu({event: selectedEvent.event, Icon, setSelectedEvent, tapEvent: selectedEvent.tapEvent, viewRef: selectedEvent.viewRef})}
       </View>
     </>
@@ -297,7 +673,7 @@ ChatScreen.propTypes = {
   navigation: NavigationPropType,
   route: PropTypes.shape({
     params: PropTypes.shape({
-      conversation: ConversationPropType.isRequired,
+      conversation: string,
     }),
   }),
 };
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js b/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
index 845ad14..88003f4 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
@@ -8,7 +8,6 @@ import Colors from "../constants/Colors";
 
 
 import ReactNativeHapticFeedback from "react-native-haptic-feedback";
-import { ClientContext } from "../../../src/context/ClientContext";
 
 
 const chatSelf = require("../images/chat_gray.png");
@@ -146,10 +145,11 @@ const styles = StyleSheet.create({
   }
 });
 
-function Message({ event, text, time, author, isOwn, encrypted, setSelectedEvent, Icon }) {
+function Message({ event, text, time, author, isOwn, encrypted, setSelectedEvent, Icon, conversation }) {
   const viewRef = React.useRef();
   const [likes, setLikes] = React.useState(0);
   const ctx = React.useContext(ChatContext);
+  const alone = conversation.participants.length == 1;
   const options = {
     enableVibrateFallback: true,
     ignoreAndroidSystemSettings: false
@@ -181,6 +181,7 @@ function Message({ event, text, time, author, isOwn, encrypted, setSelectedEvent
   },[]);
   const authorUrl = event.avatar || getAvatar(author);
   const contactName = event.contactName || (!isOwn ? ctx.getContactName(ctx.getUsernameByUserId(author)) : "Me");
+  
   return (
     <>
       <TouchableHighlight ref={viewRef} underlayColor={"#bbb"} style={isOwn ? styles.selfMessage : styles.message} delayLongPress={500} onPress={(evt) => {
@@ -203,7 +204,7 @@ function Message({ event, text, time, author, isOwn, encrypted, setSelectedEvent
             {isOwn && (
               <>
                 <Text style={styles.readIndicator}>
-                  <Icon name="ticks" color={event?.readBy?.length > 0 ? "rgb(228,140,58)" : "rgb(100,100,100)"} size={8} />
+                  <Icon name="ticks" color={event?.readBy?.length > 0 || alone ? "rgb(228,140,58)" : "rgb(100,100,100)"} size={8} />
                 </Text>
                 <Text style={styles.deliveryIndicator}>
                   <Icon name="ticks" color={event?.is_delivered ? "rgb(228,140,58)" : "rgb(100,100,100)"} size={8}/>
@@ -226,7 +227,8 @@ Message.propTypes = {
   setShowMenu: PropTypes.func,
 };
 
-export default function MessageItem ({ event, menu, setSelectedEvent }) {
+export default function MessageItem ({ event, setSelectedEvent, conversation }) {
+
   const ctx = React.useContext(ChatContext);
   const username = ctx.getUserId();
   const isMessage = event?.type === "MESSAGE";
@@ -234,7 +236,7 @@ export default function MessageItem ({ event, menu, setSelectedEvent }) {
   const isOwn = !author || author == username;
   if (isMessage) {
     if (event?.hidden) return null;
-    return (<Message Icon={ctx.icon} menu={menu} setSelectedEvent={setSelectedEvent} event={event} text={event?.text} isOwn={isOwn} author={author} time={event?.time} encrypted={event?.encrypted} />);
+    return (<Message conversation={conversation} Icon={ctx.icon} setSelectedEvent={setSelectedEvent} event={event} text={event?.text} isOwn={isOwn} author={author} time={event?.time} encrypted={event?.encrypted} />);
   } else {
     return (<Text style={styles.notification}>{event?.text}</Text>);
   }
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js b/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
index 2fbc6d2..85a0bf2 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
@@ -6,8 +6,8 @@ import MessageItem from "./MessageItem";
 import { EventPropType } from "../PropTypes";
 import {StyleSheet} from 'react-native';
 
-function renderItem({ item, setSelectedEvent }) {
-  return (<MessageItem event={item} setSelectedEvent={setSelectedEvent} />);
+function renderItem({ item, setSelectedEvent, conversation }) {
+  return (<MessageItem event={item} setSelectedEvent={setSelectedEvent} conversation={conversation} />);
 }
 renderItem.propTypes = {
   item: EventPropType,
@@ -20,7 +20,7 @@ const renderCell = ({index, style, ...props}) => {
 
 
 
-export default function MessageList({ events, onEndReached, setSelectedEvent }) {
+export default function MessageList({ conversation, events, onEndReached, setSelectedEvent }) {
   const flatlistRef = React.useRef();
   const [goToBottom, setGoToBottom] = React.useState(false);
   const scrollToEnd = React.useCallback(() => {
@@ -44,7 +44,7 @@ export default function MessageList({ events, onEndReached, setSelectedEvent })
         contentContainerStyle={{ paddingBottom: 20 }}
         inverted
         data={[...events].reverse()}
-        renderItem={({item}) => renderItem({item, setSelectedEvent})}
+        renderItem={({item}) => renderItem({item, setSelectedEvent, conversation})}
         onEndReached={onEndReached}
         onEndReachedThreshold={0.5}
         removeClippedSubviews={false}
diff --git a/node_modules/react-native-chat-plugin/Components/Header.js b/node_modules/react-native-chat-plugin/Components/Header.js
index 738ea59..ba39223 100644
--- a/node_modules/react-native-chat-plugin/Components/Header.js
+++ b/node_modules/react-native-chat-plugin/Components/Header.js
@@ -1,5 +1,5 @@
 import React from "react";
-import { Text, View, StyleSheet, Image } from "react-native";
+import { Text, View, StyleSheet, Image, TouchableOpacity } from "react-native";
 import PropTypes from "prop-types";
 import Colors from "../constants/Colors";
 import moment from "moment";
@@ -23,9 +23,8 @@ const styles = StyleSheet.create({
     width: 30,
     height: 30,
     borderRadius: 30,
-    marginRight: 20,
     position: "absolute",
-    left: 30,
+    left: 40,
     top: 0,
   },
   lastOnline: {
@@ -43,8 +42,14 @@ const styles = StyleSheet.create({
     paddingHorizontal: 100,
   }
 });
-
-export default function Header({ left, right, title, avatar, lastOnline }) {
+const Avatar = ({avatar}) => {
+  if (typeof avatar == 'string') return <Image source={{url: avatar}} style={styles.avatar} />
+  return avatar  ? avatar.slice(0,5).map((a,i) => 
+    <Image source={{url: a}} style={{...styles.avatar, zIndex: i*1, left: 30+i*20}} />
+  ) : null;
+}
+export default function Header({ left, right, title, avatar, lastOnline, onPress }) {
+  //console.error(avatar);
   if (lastOnline) {
     moment.locale('en')
     var lastOnlineHumanized = moment(lastOnline).fromNow();
@@ -52,13 +57,13 @@ export default function Header({ left, right, title, avatar, lastOnline }) {
   return (
     <View style={styles.topContainer}>
       {left ? left : <View style={styles.emptyView} />}
-      <View style={styles.userInfo}>
-        {!!avatar && <Image source={{url:avatar}} style={styles.avatar} />}
+      <TouchableOpacity onPress={onPress ? onPress : () => {}} style={styles.userInfo}>
+        <Avatar avatar={avatar} />
         <View style={styles.chatName}>
           {title ? <Text style={styles.title} numberOfLines={1} ellipsizeMode={"tail"}>{title}</Text> : null}
           {lastOnline ? <Text style={styles.lastOnline} numberOfLines={1} ellipsizeMode={"tail"}>Online: {lastOnlineHumanized}</Text> : null}
         </View>
-      </View>
+      </TouchableOpacity>
       {right ? right : <View style={styles.emptyView} />}
     </View>
   );
diff --git a/node_modules/react-native-chat-plugin/Components/ProfilePreview.js b/node_modules/react-native-chat-plugin/Components/ProfilePreview.js
index 904817b..918c12d 100644
--- a/node_modules/react-native-chat-plugin/Components/ProfilePreview.js
+++ b/node_modules/react-native-chat-plugin/Components/ProfilePreview.js
@@ -1,8 +1,6 @@
 import React from "react";
 import { View, Text, StyleSheet, Image } from "react-native";
 import PropTypes from "prop-types";
-
-import Colors from "../constants/Colors";
 import { UserPropType } from "../PropTypes";
 
 const styles = StyleSheet.create(
@@ -41,23 +39,14 @@ const styles = StyleSheet.create(
     }
   }
 );
-
+const defaultAvatar = require("../images/profile.png");
 const weviveLogo = require("../../../src/images/PNG/wewelogo.png");
 
-function ProfilePreview({ text, contacts, size }) {
-  const imageUrls = contacts && contacts.filter(p => p.avatar).map(p => p.avatar);
-  
-  let color = null;//contacts && contacts.filter(p => p.color && p.color.length > 0).map(p => p.color)[0];
-  if (!color) {
-    color = Colors.ACCENT2;
-  } else {
-    if (color.length === 6) {
-      color = "#" + color;
-    }
-  }
-  const avatarSource = imageUrls[0] == 'default' ? weviveLogo : { uri: imageUrls[0] };
+function ProfilePreview({ text, contacts, size, conversation }) {
+  const imageUrls = !conversation || !conversation.avatar || typeof conversation.avatar == 'undefined' ? (contacts && contacts.filter(p => p.avatar).map(p => p.avatar)) : [conversation.avatar];
+  const avatarSource = !imageUrls || imageUrls[0] == 'default' ? weviveLogo : { uri: imageUrls[0] };
   let child;
-  if (imageUrls[0] == 'default') {
+  if (avatarSource == weviveLogo) {
     child = <Image style={[styles.image, { height: size + 1, width: size + 1 }]} source={avatarSource} />;
   } else if (Array.isArray(imageUrls) && imageUrls.length > 0) {
     child = <Image style={[styles.image, { height: size - 8, width: size - 8 }]} source={avatarSource} />;
@@ -66,7 +55,7 @@ function ProfilePreview({ text, contacts, size }) {
     //size = size || 50;
     //child = <Text style={styles.initials}>{initials}</Text>;
     child = <View style={[styles.emptyProfileContainer, { height: size - 8, width: size - 8 }]}>
-      <Image style={[styles.emptyProfileImage, { height: size - 8, width: size - 8 }]} source={require("../images/profile.png")} />
+      <Image style={[styles.emptyProfileImage, { height: size - 8, width: size - 8 }]} source={defaultAvatar} />
     </View>;
   }
 
@@ -78,7 +67,6 @@ function ProfilePreview({ text, contacts, size }) {
         {
           width: size,
           height: size,
-          backgroundColor: color,
         }
       ]}>
       {child}
diff --git a/node_modules/react-native-chat-plugin/Components/TextInput.js b/node_modules/react-native-chat-plugin/Components/TextInput.js
index 3658991..3b3f1d2 100644
--- a/node_modules/react-native-chat-plugin/Components/TextInput.js
+++ b/node_modules/react-native-chat-plugin/Components/TextInput.js
@@ -1,7 +1,7 @@
 import React from "react";
 import PropTypes from "prop-types";
 import { TextInput as RNTextInput, View, StyleSheet, Image } from "react-native";
-import { responsiveWidth } from "react-native-responsive-dimensions";
+import { responsiveFontSize, responsiveWidth } from "react-native-responsive-dimensions";
 const searchIcon = require("../images/search_icon.png");
 const styles = StyleSheet.create({
   textContainer: {
@@ -19,27 +19,30 @@ const styles = StyleSheet.create({
   searchContainer: {
     margin: 10,
     marginHorizontal: 22,
-    backgroundColor: "rgb(235,235,235)",
-    padding: 10,
+    backgroundColor: "rgb(210,210,210)",
+    paddingHorizontal: 10,
     borderRadius: 6,
-    paddingLeft: 40,
+    paddingLeft: 28,
     borderWidth:1,
     borderColor: "#c2c2c2",
+    padding: 2,
   },
   searchText: {
     color: "rgb(125,125,125)",
     padding: 0,
-    fontWeight: "700"
+    fontSize: responsiveFontSize(1.8),
+    fontWeight: "400",
+    height: responsiveWidth(5),
   },
   searchParent: {
     padding: 0,
   },
   searchIcon: {
     position: "absolute",
-    width: 25,
-    height: 25,
-    top: 7,
-    left: 10,
+    top: 4,
+    width: responsiveWidth(4),
+    height: responsiveWidth(4),
+    left: 7,
   }
 });
 
diff --git a/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js b/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
index e1f4aab..ac85483 100644
--- a/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
+++ b/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
@@ -12,7 +12,9 @@ import TypingIndicator from "react-native-chat-plugin/ChatScreen/TypingIndicator
 const styles = StyleSheet.create(
   {
     container: {
-      backgroundColor: "red",
+      backgroundColor: "white",
+      borderBottomWidth: 1,
+      borderBottomColor: "#ddd",
       flexDirection: "row",
       padding: 20,
     },
@@ -114,13 +116,14 @@ function getPreviewDate(conversation, user, Icon) {
 }
 function getPreview(conversation) {
   let event = conversation.lastEvent;
+  //console.error(event);
   const prefix = "";// event?.owner?.username ? event.owner.username + ": " : "";
   const preview = (typeof event?.text === "string") ? event.text.length > 128 ? event.text.substring(0,128)+".." : event.text : "No Messages yet.";
 
   return `${prefix}${preview}`;
 }
 const lockIcon = require("../images/lock_icon.png");
-export default function ContactComponent({ conversation, onPress }) {
+export default function ContactComponent({ conversation, onPress, onLongPress }) {
   const unreadCount = conversation.unreadCount ? parseInt(conversation.unreadCount) : 0;
   const ctx = useContext(ChatContext);
   const user = ctx.getUser();
@@ -134,8 +137,9 @@ export default function ContactComponent({ conversation, onPress }) {
   return (
     <TouchableHighlight
       onPress={() => (onPress && onPress(conversation))}
+      onLongPress={() => onLongPress && onLongPress(conversation)}
       underlayColor="#F8E2DD">
-      <LinearGradient style={styles.container} colors={['#ffffff', '#f3f3f3']}>
+      <View style={styles.container} colors={['#ffffff', '#f3f3f3']}>
         <ProfilePreview text={chatName} contacts={participants} conversation={conversation} />
         
         <View>
@@ -158,7 +162,7 @@ export default function ContactComponent({ conversation, onPress }) {
             <Text style={styles.unreadCountText}>{unreadCount}</Text>
           </View>
         ) : null }
-      </LinearGradient>
+      </View>
 
     </TouchableHighlight>
   );
diff --git a/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js b/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
index a73d2b3..610a817 100644
--- a/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
@@ -1,5 +1,5 @@
 import React from "react";
-import { View, StyleSheet, Text, TouchableOpacity, ImageBackground } from "react-native";
+import { View, StyleSheet, Text, TouchableOpacity, ImageBackground, Alert } from "react-native";
 import { SwipeListView } from "react-native-swipe-list-view";
 
 //import AlphabetList from "react-native-flatlist-alphabet";
@@ -11,9 +11,38 @@ import { NavigationPropType } from "../PropTypes";
 import TextInput from "../Components/TextInput";
 //import Colors from "../constants/Colors";
 import { searchForMessages } from "../utils/ChatEncryption";
+import {ActionSheetCustom} from "@alessiocancian/react-native-actionsheet";
+import Icon from "../../../src/components/Icon";
+import { responsiveFontSize, responsiveWidth } from "react-native-responsive-dimensions";
+import APIService from "../../../src/service/APIService";
+const ActionSheetElement = (props) => {
+  return (
+    <View style={styles.menuItem}>
+      <Text style={styles.menuText}>{props.text}</Text>
+      <Icon name={props.icon} style={styles.menuIcon} />
+    </View>
+  );
+};
 //import LinearGradient from "react-native-linear-gradient";
-const closeIcon = require("../images/close.png");
 const styles = StyleSheet.create({
+  menuItem: {
+    flexDirection: 'row',
+  },
+  menuText: {
+    marginRight: responsiveWidth(3),
+    width: responsiveWidth(14),
+    textAlign: 'center',
+    fontWeight: '100',
+    fontSize: responsiveFontSize(2.2),
+    fontFamily: 'SFProDisplay-Regular',
+    color: "red",
+  },
+  menuIcon: {
+    fontSize: responsiveWidth(4),
+    color: 'rgb(100,100,100)',
+    color: "red",
+    alignSelf: 'center',
+  },
   container: {
     flex: 1,
     zIndex: 1,
@@ -145,32 +174,23 @@ const staticConversations = [
     lastEvent: {
       text: "Latest news",
       owner: {
-        id: 999
+        id: "-1"
       },
       time: Date()
     },
+    participants: [],
     events: [
       {
         id: -998,
-        text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent sollicitudin posuere dui et gravida. Ut efficitur a ligula at hendrerit. Praesent gravida metus iaculis magna facilisis fermentum. Nunc erat lorem, ultrices vel cursus eget, sodales nec libero. In aliquam volutpat justo quis sagittis. Quisque molestie dolor eget massa egestas cursus. Suspendisse massa mauris, accumsan eget fermentum a, vulputate at ex. Ut id risus lacinia magna tincidunt pretium at non lacus. Donec tempor justo a ullamcorper ultricies. Nunc porttitor dictum tellus, non tempor nibh.",
-        type: "MESSAGE",
-        contactName: "Wevive",
-        avatar: 'default',
-        owner: {
-          id: 999,
-          name: "AA",
-          username: "asd"
-        },
-        time: Date()
-      },
-      {
-        id: -999,
-        text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent sollicitudin posuere dui et gravida. Ut efficitur a ligula at hendrerit. Praesent gravida metus iaculis magna facilisis fermentum. Nunc erat lorem, ultrices vel cursus eget, sodales nec libero. In aliquam volutpat justo quis sagittis. Quisque molestie dolor eget massa egestas cursus. Suspendisse massa mauris, accumsan eget fermentum a, vulputate at ex. Ut id risus lacinia magna tincidunt pretium at non lacus. Donec tempor justo a ullamcorper ultricies. Nunc porttitor dictum tellus, non tempor nibh.",
+        text: `Our mission is to accelerate the worlds transition to a better planet.
+Bringing a positive change to technology and our communities is ambitious. But it is through collaboration and collective action that this can be achieved.
+We offer innovative platforms, deployed at-scale whilst partnering with communities around the world.
+Wevive Talk is our first product and is a carbon neutral communication app. Its goal is to connect people without negatively impacting the environment as well as the users privacy and data.`,
         type: "MESSAGE",
         contactName: "Wevive",
         avatar: 'default',
         owner: {
-          id: 999,
+          id: "-1",
           name: "AA",
           username: "asd"
         },
@@ -178,7 +198,7 @@ const staticConversations = [
       }
     ],
     owner: {
-      id: 999
+      id: "-1",
     },
     participants: [
       {
@@ -188,9 +208,11 @@ const staticConversations = [
     ]
   }
 ]
+let selectedConversation = null;
 export default function ContactsScreen({ navigation, route }) {
   const ctx = React.useContext(ChatContext);
   const swiper = React.useRef();
+  const actionSheetRef = React.useRef();
   const filter = route.params?.filter;
   //ctx.addConversation(staticConversations[0]);
   const conversations = filter == 'groups' ? staticConversations : ctx.getConversations()
@@ -199,8 +221,36 @@ export default function ContactsScreen({ navigation, route }) {
   //.filter(c => route.params.type == 'pinned' && !c.pinned)
   const [results, setResults] = React.useState([]);
   const onPress = (conversation) => {
-    navigation.navigate("ChatScreen", { conversation });
+    navigation.navigate("ChatScreen", { conversation:conversation.id, conversationObject: filter === 'groups' ? conversation : null});
   };
+  const onLongPress = (conversation) => {
+    actionSheetRef.current.show();
+    selectedConversation = conversation;
+  }
+  const processActionSheet = (action) => {
+    if (action == 0) {
+      ctx.deleteConversation(selectedConversation.id, false);
+      APIService('messages/report/',{conversation: selectedConversation});
+          Alert.prompt("Chat conversation blocked", "Would you like to report it too?", [
+            {text: 'No', onPress: () => {}},
+            {text: 'Yes', onPress: () => Alert.alert('User reported'), style:"destructive"},
+      ], 'default');
+    } else if (action == 1) {
+      ctx.deleteConversation(selectedConversation.id, false);
+      APIService('messages/report/',{conversation: selectedConversation});
+          Alert.prompt("Chat conversation reported", "Would you like to block it too?", [
+            {text: 'No', onPress: () => {}},
+            {text: 'Yes', onPress: () => Alert.alert('User blocked'), style:"destructive"},
+      ], 'default');
+    } else if (action == 2) {
+      //
+    }
+  }
+  const actionSheet = [
+    <ActionSheetElement text="Block" icon="alert-triangle" />,
+    <ActionSheetElement text="Report" icon="alert-triangle" />,
+    'Cancel',
+  ];
   const [query, setQuery] = React.useState("");
   function searchAsyncForMessages(ctx, query) {
     searchForMessages(ctx, query).then((resultsFromDB) => {
@@ -209,6 +259,16 @@ export default function ContactsScreen({ navigation, route }) {
       }
     });
   }
+  const convSort = (a,b) => {
+    if (a.pinned && !b.pinned) return false;
+    if (a.lastEvent && b.lastEvent) {
+      return +new Date(a.lastEvent.time) < +new Date(b.lastEvent.time);
+    } else if (a.lastEvent) {
+      return +new Date(a.lastEvent.time) < +new Date(b.time);
+    } else if (b.lastEvent) {
+      return +new Date(a.time) < +new Date(b.lastEvent.time);
+    }
+  }
   const displayConversations = React.useMemo(() => {
     const convMatches = [...conversations];
     if (query && query.length > 0) {
@@ -228,7 +288,7 @@ export default function ContactsScreen({ navigation, route }) {
       }
       return convMatches.filter(conversation => {
         return (conversation.match !== undefined && conversation.match) || conversation.name.toString().toLowerCase().indexOf(query.toLowerCase()) >= 0;
-      });
+      }).sort(convSort);
     } else {
       convMatches.forEach((conv, index) => {
         convMatches[index].match = false;
@@ -236,15 +296,14 @@ export default function ContactsScreen({ navigation, route }) {
           convMatches[index].lastEvent = convMatches[index].originalLastEvent;
         }
       });
-      return convMatches;
+      return convMatches.sort(convSort);
     }
   }, [query, conversations, results]);
-
   const keyExtractor = item => item.id;
 
   const renderConversation = ({item}) => {
     return (
-      <ContactComponent conversation={item} onPress={onPress} />
+      <ContactComponent conversation={item} onPress={onPress} onLongPress={onLongPress} />
     );
   };
   const markConversation = React.useCallback((conversation, type, value) => {
@@ -273,7 +332,6 @@ export default function ContactsScreen({ navigation, route }) {
     swiper.current?.closeAllOpenRows();
   },[]);
   const renderHiddenItem = ({item}) => {
-    const Icon = ctx.icon;
     return (
       <View style={styles.hiddenItemContainer}>
         <View style={styles.leftSwipeContainer}>
@@ -338,6 +396,12 @@ export default function ContactsScreen({ navigation, route }) {
           useNativeDriver
           ref={swiper}
         />
+        <ActionSheetCustom
+            ref={actionSheetRef}
+            title={''}
+            options={actionSheet}
+            onPress={processActionSheet}
+        />
       </ImageBackground>
     </View>
   );
diff --git a/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js b/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
index 389e406..f67a0e0 100644
--- a/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
@@ -1,18 +1,20 @@
 import React from "react";
-import { View, StyleSheet, Text, TouchableOpacity, FlatList } from "react-native";
+import { View, StyleSheet, Text, TouchableOpacity, FlatList, SectionList, Switch, Pressable } from "react-native";
 
-//import AlphabetList from "react-native-flatlist-alphabet";
+import AlphabetList from "react-native-flatlist-alphabet";
 import { ChatContext } from "../ChatContext";
 import { NavigationPropType } from "../PropTypes";
 import LinearGradient from "react-native-linear-gradient";
 
 import SendSMS from 'react-native-sms'
-import { responsiveFontSize } from "react-native-responsive-dimensions";
+import { responsiveFontSize, responsiveWidth } from "react-native-responsive-dimensions";
 import APIService from "../../../src/service/APIService";
 import {ClientContext} from '../../../src/context/ClientContext';
 import { clearPhoneNumber } from "../../../src/utils/phonehelpers";
 import trans from "../../../src/utils/trans";
 import Icon from "../../../src/components/Icon";
+import getSectionData from "react-native-flatlist-alphabet/dist/utilities/getSectionData";
+import TextInput from "react-native-chat-plugin/Components/TextInput";
 
 
 const styles = StyleSheet.create({
@@ -83,6 +85,9 @@ const styles = StyleSheet.create({
     flexDirection: "row",
     justifyContent: "space-between",
     paddingRight: 50,
+    backgroundColor: "white",
+    borderBottomWidth: 1,
+    borderBottomColor: "#ddd",
   },
   sectionHeaderContainer: {
     backgroundColor: "rgb(125,125,125)",
@@ -102,8 +107,8 @@ const styles = StyleSheet.create({
   },
   letterItemStyle: {
     //padding: 10,
-    height: 20,
-    width: 30,
+    height: responsiveWidth(5),
+    width: responsiveWidth(5),
   },
   contactToggle: {
     backgroundColor: "transparent",
@@ -123,13 +128,39 @@ const styles = StyleSheet.create({
     justifyContent: "center",
   },
   headerStyle: {
-    backgroundColor: "rgb(125,125,125)",
-    padding: 20,
+    backgroundColor: "white",
+    paddingTop: responsiveWidth(10),
+    paddingHorizontal: 20,
     flexDirection: "row",
     justifyContent: "space-between",
   },
+  headerCancel: {
+    flexDirection: "column",
+    justifyContent: "center",
+  },
   headerButtonStyle: {
-    color: "white",
+    fontSize: responsiveFontSize(2.1),
+    alignSelf: "center",
+    color: "black",
+    zIndex: 99,
+  },
+  headerHeadline: {
+    flexDirection: "column",
+    alignContent: "center",
+    justifyContent: "center",
+    flex: 1,
+    position: "absolute",
+    width: responsiveWidth(100),
+    bottom: responsiveWidth(0),
+  },
+  headerHeadlineText: {
+    fontSize: responsiveFontSize(2),
+    alignSelf: "center",
+  },
+  headerIcon: {
+    color: "rgb(120,170,120)",
+    fontSize: responsiveFontSize(2),
+    alignSelf: "center",
   },
   markTick: {
     color: "white",
@@ -150,6 +181,35 @@ const styles = StyleSheet.create({
     position: "absolute",
     left: 20,
     bottom: 10,
+  },
+  toggleStyle: {
+    transform: [
+      {scale: 0.8},
+    ],
+    position: "absolute",
+    left: responsiveWidth(20),
+    top: responsiveWidth(5),
+  },
+  toggleTextBox: {
+    flexDirection: "row",
+    marginBottom: responsiveWidth(2),
+    marginHorizontal: responsiveWidth(7),
+  },
+  toggleTextStyle: {
+    fontSize: responsiveFontSize(1.5),
+    color: "rgb(100,100,100)",
+    backgroundColor: "rgb(210,210,210)",
+    padding: responsiveWidth(3),
+    padding: responsiveWidth(3),
+    flex: 1, 
+  },
+  toggleTextStyleSelected: {
+    fontSize: responsiveFontSize(1.5),
+    color: "white",
+    backgroundColor: "rgb(218, 135, 71)",
+    padding: responsiveWidth(3),
+    padding: responsiveWidth(3),
+    flex: 1, 
   }
 });
 
@@ -162,7 +222,7 @@ const onShare = async (numbers, navigation) => {
     allowAndroidSendWithoutReadPermission: true,
   }, (completed, cancelled, error) => {
     if (completed) {
-      navigation.navigate('SearchContactsScreen');
+      navigation.navigate('SearchContactsScreen', {type: "private"});
     }
     //console.warn('SMS Callback: completed: ' + completed + ' cancelled: ' + cancelled + 'error: ' + error);
   });
@@ -170,7 +230,6 @@ const onShare = async (numbers, navigation) => {
 
 
 const renderSectionHeader = (section) => {
-  //return null;
   return (
     <View style={styles.sectionHeaderContainer}>
       <Text style={styles.sectionHeaderLabel}>{section.title}</Text>
@@ -178,21 +237,46 @@ const renderSectionHeader = (section) => {
   );
 };
 
+class Contact extends React.PureComponent {
+  render() {
+    const {label, humanValue, clearLabel, alreadyExists, numberOfFriends, marked, toggleSelected, navigation, conversations} = this.props;
+    const onPress = () => {
+      if (!alreadyExists) {
+        toggleSelected(label, marked)
+      } else {
         
-const Contact = ({label, humanValue, clearLabel, alreadyExists, numberOfFriends, marked, toggleSelected}) => {
-  return (
-    <TouchableOpacity onPress={()=>!alreadyExists && toggleSelected(label, marked)}>
-      <LinearGradient style={styles.listItemContainer} colors={['#fff','#f3f3f3']}>
-        <Text style={styles.listItemLabel}>{humanValue}</Text>
-        {alreadyExists && <Text style={styles.alreadyExists}>Wevive user</Text>}
-        {!alreadyExists && numberOfFriends > 0 && <Text style={styles.numberOfFriends}>{trans('chats.friend_of_',{count:numberOfFriends})}</Text>}
-        {!alreadyExists && <View style={!!marked ? styles.markedContactToggle : styles.contactToggle}>
-          {!!marked && <Icon name="ticks" style={styles.markTick}/>}
-        </View>}
-      </LinearGradient>
-    </TouchableOpacity>
-  );
-};
+        const oneToOne = conversations
+        .filter(c =>
+          c.participants.findIndex(p => p.username == clearLabel) !== -1 
+        )
+        .filter(c =>
+          !c.name || c.name == ''
+        ).filter(c =>
+          {
+            return c.participants.length < 3
+          }
+        );
+        if (oneToOne.length) {
+          navigation.navigate('ChatScreen', {conversation: oneToOne[0].id});
+        } else {
+          navigation.navigate('SearchContactsScreen', {type: "oneToOne", user: clearLabel });
+        }
+      }
+    }
+    return (
+      <TouchableOpacity onPress={onPress}>
+        <View style={styles.listItemContainer} colors={['#fff','#f3f3f3']}>
+          <Text style={styles.listItemLabel}>{humanValue}</Text>
+          {alreadyExists && <Text style={styles.alreadyExists}>Wevive user</Text>}
+          {!alreadyExists && numberOfFriends > 0 && <Text style={styles.numberOfFriends}>{trans('chats.friend_of_',{count:numberOfFriends})}</Text>}
+          {!alreadyExists && <View style={!!marked ? styles.markedContactToggle : styles.contactToggle}>
+            {!!marked && <Icon name="ticks" style={styles.markTick}/>}
+          </View>}
+        </View>
+      </TouchableOpacity>
+    );
+  }
+}
 
 export default function PhoneContactsScreen({ navigation }) {
   
@@ -200,36 +284,74 @@ export default function PhoneContactsScreen({ navigation }) {
   const clientctx = React.useContext(ClientContext);
   const [selectedContacts, setSelectedContacts] = React.useState([]);
   const [filter, setFilter] = React.useState(false)
-  const [existingUsers, setExistingUsers] = React.useState({existing:[],contacts:[],friendCounts: []});
+  const [usersOnly, setUsersOnly] = React.useState(true);
+  const [existingUsers, setExistingUsers] = React.useState({existing:[],contacts:[],friendCounts: [],init:false});
   const contacts = ctx.getPhoneContacts();
+  const conversations = ctx.getConversations();
+  const [query, setQuery] = React.useState("");
+  function searchAsyncForContacts(ctx, query) {
+    searchForMessages(ctx, query).then((resultsFromDB) => {
+      if (JSON.stringify(resultsFromDB) != JSON.stringify(results)) {
+        setResults(resultsFromDB);
+      }
+    });
+  }
+  const displayContacts = React.useMemo(() => {
+    if (query && query.length > 0) {
+      const searchRegex = new RegExp(`${query}`, 'g');
+      return contacts.filter((c) => 
+        searchRegex.test(String(c.humanValue))
+        ||
+        searchRegex.test(String(c.clearLabel))
+        ||
+        searchRegex.test(String(c.label))
+      );
+    } else {
+      return contacts;
+    }
+  }, [query, contacts]);
   const getNumbers = () => {
     const numbers = [];
     contacts.forEach(c => {
       if (!c.labels) {
-        numbers.push(clearPhoneNumber(clientctx.geo.geo.country_code, c.label))
+        numbers.push(c.clearLabel)
       } else {
         c.labels.forEach(l => {
-          numbers.push(clearPhoneNumber(clientctx.geo.geo.country_code, l))
+          numbers.push(c.clearLabel)
         })
       }
     });
-    return numbers;
+    return [...new Set(numbers)];
   };
   React.useEffect(() => {
     const friends = [];
     const friendCounts = [];
-    APIService('phone-contacts/sync/',{numbers: getNumbers()}).then((r)=>{
-      r.contacts.forEach(u => {
-        friends.push(u.phone_number);
-        friendCounts.push(u.users);
-      });
+    global.appIsLoading('Syncing contacts..');
+    if (!global.isInternetReachable) {
+      global.appIsNotLoading();
       setExistingUsers(
         {
-          existing: r.users.map(u => u.phone_number),
-          contacts: friends,
-          friendCounts: friendCounts,
+          ...existingUsers,
+          init: true,
         }
       );
+    }
+    APIService('phone-contacts/sync/',{numbers: getNumbers()}).then((r)=>{
+      global.appIsNotLoading();
+      if (r.contacts) {
+        r.contacts.forEach(u => {
+          friends.push(u.phone_number);
+          friendCounts.push(u.users);
+        });
+        setExistingUsers(
+          {
+            existing: r.users.map(u => u.phone_number),
+            contacts: friends,
+            friendCounts: friendCounts,
+            init: true,
+          }
+        );
+      }
     });
   },[]);
   const toggleSelected = (label, marked) => {
@@ -246,42 +368,67 @@ export default function PhoneContactsScreen({ navigation }) {
   const goNext = () => {
     onShare(selectedContacts, navigation);
   }
-  const renderItem = ({item}) => 
-    <Contact
+  const renderItem = (item) => {
+    return <Contact
+      conversations={conversations}
+      navigation={navigation}
       toggleSelected={toggleSelected}
-      alreadyExists={existingUsers.existing.indexOf(item.clearNumber) !== -1}
+      alreadyExists={existingUsers.existing.indexOf(item.clearLabel) !== -1}
       label={item.label}
-      key={item.value}
+      clearLabel={item.clearLabel}
+      //key={item.value}
       humanValue={item.humanValue}
       marked={selectedContacts.indexOf(item.label) !== -1}
-      numberOfFriends={existingUsers.contacts && existingUsers.contacts.indexOf(item.clearNumber) !== -1 ? existingUsers.friendCounts[existingUsers.contacts.indexOf(item.clearNumber)] - 1 : 0}
+      numberOfFriends={existingUsers.contacts && existingUsers.contacts.indexOf(item.clearLabel) !== -1 ? existingUsers.friendCounts[existingUsers.contacts.indexOf(item.clearLabel)] - 1 : 0}
     />;
-  return contacts && (
+  }
+  //sections = getSectionData(displayContacts || contacts || []);
+  return contacts && existingUsers.init && (
     <>
+
       <View style={styles.headerStyle}>
-        <TouchableOpacity onPress={goBack}>
+
+        <View style={styles.headerHeadline}>
+          <Icon name="add" style={styles.headerIcon} />
+          <Text style={styles.headerHeadlineText}>Contacts</Text>
+        </View>
+        <TouchableOpacity onPress={goBack} style={styles.headerCancel}>
           <Text style={styles.headerButtonStyle}>Cancel</Text>
         </TouchableOpacity>
+        {selectedContacts.length == 0 && 
+        <Text style={styles.headerButtonStyle}>{selectedContacts.length > 0 ? selectedContacts.length : contacts.length} {selectedContacts.length > 0 ? "selected" : "contacts"} </Text>}
         {selectedContacts.length > 0 && <TouchableOpacity onPress={goNext}>
           <Text style={styles.headerButtonStyle}>Next</Text>
         </TouchableOpacity>}
       </View>
+      <TextInput placeholder={"Search"} onChangeText={query => setQuery(query)} />
+      <Pressable onPress={()=>{
+          setUsersOnly(!usersOnly);
+        }} style={styles.toggleTextBox}>
+          <Text style={!usersOnly ? styles.toggleTextStyle : styles.toggleTextStyleSelected}>Wevive users</Text>
+          <Text style={usersOnly ? styles.toggleTextStyle : styles.toggleTextStyleSelected}>All contacts</Text>
+      </Pressable>
+      
       <View style={styles.container}>
-        <FlatList
-          data={contacts}
+        <AlphabetList
+          data={(displayContacts || contacts).filter(c=> !usersOnly || existingUsers.existing.indexOf(c.clearLabel) !== -1)}
           indexLetterColor={'white'}
-          indexLetterSize={15}
+          indexLetterSize={responsiveWidth(3.5)}
           alphabetContainer={styles.alphabetContainer}
           renderItem={renderItem}
           renderSectionHeader={renderSectionHeader}
           letterItemStyle={styles.letterItemStyle}
-          keyExtractor={(c) => c.label}
+          //keyExtractor={(c) => c.label}
+          //maxToRenderPerBatch={20}
+          //windowSize={3}
+          //updateCellsBatchingPeriod={1}
+          //initialNumToRender={10}
         />
       </View>
     </>
   );
 }
-
+//Contact.whyDidYouRender = true;
 //PhoneContactsScreen.whyDidYouRender = true;
 
 PhoneContactsScreen.propTypes = {
diff --git a/node_modules/react-native-chat-plugin/PropTypes.js b/node_modules/react-native-chat-plugin/PropTypes.js
index a5e3b06..293d4ce 100644
--- a/node_modules/react-native-chat-plugin/PropTypes.js
+++ b/node_modules/react-native-chat-plugin/PropTypes.js
@@ -6,7 +6,7 @@ export const NavigationPropType = PropType.shape({
 });
 
 export const UserPropType = PropType.shape({
-  id: PropType.string,
+  id: PropType.any,
   username: PropType.string.isRequired,
   color: PropType.string,
   avatar: PropType.string,
@@ -27,6 +27,7 @@ export const ConversationPropType = PropType.shape({
   lastEvent: EventPropType,
   participants: PropType.arrayOf(UserPropType),
   typing: PropType.arrayOf(PropType.string),
+  avatar: PropType.string,
 });
 
 export const CallProptype = PropType.shape({
diff --git a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
index 99528da..16670c7 100644
--- a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
@@ -114,17 +114,21 @@ export default function SearchContactsScreen({navigation, route}) {
   const [state, dispatch] = React.useReducer(SearchReducer, SearchInitialState);
   const ctx = React.useContext(ChatContext);
   const socket = getSocket();
+  const conversationId = route.params.conversationId;
   const [conversationAvatar, setConversationAvatar] = React.useState({
     avatarImage: "",
     default: true,
   });
   const Icon = ctx.icon;
-  const createGroup = async(name) => {
-    return APIService('group/', {
-      photo: conversationAvatar.avatarImage,
+  const createGroup = async() => {
+    const options = conversationAvatar.avatarImage != "" ? {
+      group_photo: conversationAvatar.avatarImage,
       filename: conversationAvatar.avatarFile,
-      mime: conversationAvatar.avatarMime,
-      name: name,
+      mime: conversationAvatar.avatarMime
+    } : {};
+    return APIService('groups/', {
+      ...options,
+      name: conversationName ? conversationName : "Group",
     }).then((result) => {
       if (result) {
         return result;
@@ -144,13 +148,13 @@ export default function SearchContactsScreen({navigation, route}) {
   const contacts = ctx.getPhoneContacts();
   const [friends, setFriends] = React.useState([]);
   React.useEffect(() =>{
+    const country = clientctx.geo.country_code;
     const ffriends = {};
     contacts.forEach(c => {
-      const cleanedNumber = clearPhoneNumber(clientctx.geo.geo.country_code, c.label);
-      ffriends[cleanedNumber] = c.humanValue;
+      ffriends[c.clearLabel] = c.humanValue;
     });
     setFriends(ffriends);
-  },[]);
+  },[clientctx]);
 
   const getUsers = () => {
     if (!query) {
@@ -201,21 +205,31 @@ export default function SearchContactsScreen({navigation, route}) {
   const createChat = () => {
     nextButton = () => {};
     setLoading(true);
-    createGroup(conversationName).then((group) =>{
-      socket.emit(getSocketAction(), { participants: state.selected, name:conversationName, avatar: conversationAvatar.avatarImage, conversationId: route.params.conversationId }, ({ success, conversation }) => {
-        //const encrypted = conversation.participants.filter(participant => participant.public_key && participant.public_key.length).length == conversation.participants.length;
-        //if (encrypted) {
-        //  initEncryption(ctx, conversation, socket);
-        //}
-        if (success) {
+    if (!conversationId) {
+      createGroup().then((groupdata) =>{
+        const groupAvatar = conversationAvatar.avatarImage ?  JSON.parse(groupdata).group_photo_url : "";
+        socket.emit("conversations:create", { participants: state.selected, name:conversationName, avatar: groupAvatar }, ({ success, conversation }) => {
+          //const encrypted = conversation.participants.filter(participant => participant.public_key && participant.public_key.length).length == conversation.participants.length;
+          //if (encrypted) {
+          //  initEncryption(ctx, conversation, socket);
+          //}
+          if (success) {
+            ctx.addConversation(conversation);
+            navigation.replace("ChatScreen", { conversation:conversation.id, conversationObject: conversation });
+          } else {
+            Alert.alert("Error", "Creating new conversation failed, please try again.");
+            setLoading(false);
+          }
+        });
+      })
+    } else {
+      socket.emit("conversations:invite", { participants: state.selected, conversationId: conversationId},({ success, conversation }) => {
+        if (success && conversation) {
           ctx.addConversation(conversation);
-          navigation.replace("ChatScreen", { conversation });
-        } else {
-          Alert.alert("Error", "Creating new conversation failed, please try again.");
-          setLoading(false);
+          navigation.replace("ChatScreen", { conversation:conversation.id, conversationObject: conversation });
         }
       });
-    })
+    }
   };
 
   const onPress = contact => {
diff --git a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
index aab586e..5aae42c 100644
--- a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
+++ b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
@@ -46,7 +46,7 @@ const styles = StyleSheet.create(
   }
 );
 
-export default function SearchResultComponent({ contacts, contact, onPress }) {
+export default function SearchResultComponent({ contacts, contact, onPress, notSelectable }) {
   return (
     <TouchableOpacity style={styles.container} onPress={() => onPress(contact)}>
       <ProfilePreview text={contact.username} contacts={[contact]} />
@@ -54,10 +54,11 @@ export default function SearchResultComponent({ contacts, contact, onPress }) {
         <Text style={styles.name}>{contact.name}</Text>
         <Text style={styles.profileName}>{contacts && Object.keys(contacts).indexOf(contact.username) !== -1 ? contacts[contact.username] : contact.username  }</Text>
       </View>
-      {
+      {!notSelectable && (
         contact.selected
           ? <Image source={radialTick} style={[styles.selection, styles.selected]} />
           : <Image source={chatRadial} style={[styles.selection, styles.selected]} />
+          )
       }
     </TouchableOpacity>
   );
diff --git a/node_modules/react-native-chat-plugin/index.js b/node_modules/react-native-chat-plugin/index.js
index c508376..5bd6787 100644
--- a/node_modules/react-native-chat-plugin/index.js
+++ b/node_modules/react-native-chat-plugin/index.js
@@ -4,7 +4,7 @@ import PropTypes from "prop-types";
 import ChatContainer from "./ChatContainer";
 import { ChatContextProvider } from "./ChatContext";
 export { addUnreadCountListener, updateCount } from "./utils/unread-counter";
-import { ActivityIndicator, NativeModules } from 'react-native';
+import { ActivityIndicator, Alert, Linking, NativeModules, Platform, Pressable, Text, View } from 'react-native';
 import { SQLCipherClient } from "./utils/SQLCipherClient";
 import { initSocket } from "./utils/SocketIOClient";
 import { PermissionsAndroid } from 'react-native';
@@ -12,6 +12,7 @@ export const { ChatPlugin } = NativeModules;
 import Contacts from 'react-native-contacts';
 import { ClientContext } from "../../src/context/ClientContext";
 import { clearPhoneNumber } from "../../src/utils/phonehelpers";
+import Icon from "../../src/components/Icon";
 
 const getContactName = (c, reverse) => {
   let n = "";
@@ -26,8 +27,10 @@ const getContactName = (c, reverse) => {
   }
   return n;
 }
-
-export default function ChatModule({ socketIoUrl, options, icon, children }) {
+let lastSync = false;
+export default function ChatModule({ socketIoUrl, options, children }) {
+  const icon = Icon;
+  const [contactsAllowed, setContactsAllowed] = React.useState(Platform.OS == 'android' ? false : true);
   const [contacts, setContacts] = React.useState([]);
   initSocket(socketIoUrl);
   const getDB = async () => {
@@ -46,11 +49,12 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
       );
     });
   };
-  const syncTimeout = setTimeout(
+  /*const syncTimeout = setTimeout(() => setInterval(
     ()=>{
+      lastSync = false;
       syncContacts();
     }
-  , 180000);
+  , 300000), 300000);*/
   const saveContactsToDB = (contacts) => {
     getDB().then((db)=> {
       contacts.forEach(c => {
@@ -65,16 +69,16 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
     return contacts
     .filter((r)=>(r.givenName?.length || r.familyName?.length))
     .filter((r)=>(r.phoneNumbers.length > 0 && r.phoneNumbers[0].number.length))
-    .map((r)=>(
+    .map((r,i)=>(
       { 
         givenName: r.givenName,
         familyName: r.familyName,
-        key:getContactName(r, true),
+        key:i,
         humanValue:getContactName(r),
         value:getContactName(r, true),
-        labels:r.phoneNumbers.map(p=>p.number),
+        labels:r.phoneNumbers.map(p=>clearPhoneNumber(geo.country_code, p.number)),
         label: r.phoneNumbers[0].number,
-        clearLabel: clearPhoneNumber(clientctx.geo.geo.country_code, r.phoneNumbers[0].number)
+        clearLabel: clearPhoneNumber(geo.country_code, r.phoneNumbers[0].number)
       }
     ))
     .sort((a,b)=> {
@@ -82,6 +86,8 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
     });
   }
   const syncContacts = () => {
+    if (lastSync) return;
+    lastSync = +Date.now();
     if (Platform.OS == 'android') {
       PermissionsAndroid.request(
         PermissionsAndroid.PERMISSIONS.READ_CONTACTS,
@@ -91,28 +97,40 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
           'buttonPositive': 'Allow'
         }
       )
-      .then((err)=> {
-        Contacts.getAllWithoutPhotos().then(fetchedContacts => {
-          const newContacts = getClearedContacts(fetchedContacts);
-          setContacts(newContacts);
-          deleteContactsFromDB();
-          saveContactsToDB(newContacts);
-        });
+      .then((status)=> {
+        if (status == 'granted') {  
+          setContactsAllowed(true);
+          const startedSync = +Date.now()/1000;
+          Contacts.getAllWithoutPhotos().then(fetchedContacts => {
+            const endedSync = +Date.now()/1000;
+            if (options.id == '12' || options.id == '16') {
+              //Alert.alert("Contacts fetched from device in " + String(Math.floor((endedSync - startedSync)*1000)/1000)+"s");
+            }
+            const newContacts = getClearedContacts(fetchedContacts);
+            setContacts(newContacts || []);
+            //deleteContactsFromDB();
+            //saveContactsToDB(newContacts);
+            
+          });
+        }
       }
       );
     } else {
       Contacts.getAllWithoutPhotos().then(fetchedContacts => {
-        /*for (let i=0;i<1000;i++) {
-          fetchedContacts.push(
-            {"givenName": "Test "+i,"familyName":"Testo","phoneNumbers":[
-              {
-                "number":"+79211474434"+i
-              }
-            ]}
-          )
-        }*/
+        const test = false;
+        if (test) {
+          for (let i=0;i<300;i++) {
+            fetchedContacts.push(
+              {"givenName": "Test "+i,"familyName":"Testo","phoneNumbers":[
+                {
+                  "number":"+79211474434"+i
+                }
+              ]}
+            )
+          }
+        }
         const newContacts = getClearedContacts(fetchedContacts);
-        setContacts(newContacts);
+        setContacts(newContacts || []);
         deleteContactsFromDB();
         saveContactsToDB(newContacts);
       });
@@ -120,7 +138,7 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
   }
   React.useEffect(() => {
     if (!geo) return;
-    getDB().then(async (db)=> {
+    /*getDB().then(async (db)=> {
       const dbContactsArray = [];
       const [dbContacts] = await db.executeSql("SELECT * FROM contacts ORDER BY familyName ASC LIMIT 10000");
       for (let i=0;i<dbContacts.rows.length;i++) {
@@ -132,31 +150,47 @@ export default function ChatModule({ socketIoUrl, options, icon, children }) {
         });
       }
       if (false && dbContactsArray.length) {
-        setContacts(dbContactsArray);
+        setContacts(dbContactsArray || []);
         //syncContacts();
       } else {
         syncContacts();
         //clearTimeout(syncTimeout);
         
       }
-    });
+    });*/
+    syncContacts();
   },[geo]);
   React.useEffect(() => {
-    if (!contacts.length || typeof geo.geo == 'undefined') {
+    if (!contacts || !contacts.length || typeof geo == 'undefined') {
       global.appIsLoading("Loading, please wait..");
     } else {
       global.appIsNotLoading();
     }
-  },[contacts, geo])
-  return (
-    <ChatContextProvider options={options} socketIoUrl={socketIoUrl} getDB={getDB} icon={icon}>
-      <ChatContainer options={options} contacts={contacts}>
-        {children}
-      </ChatContainer>
-    </ChatContextProvider>
-  );
+  },[contacts, geo]);
+  if (!contacts || typeof geo == 'undefined') return null;
+  if (contactsAllowed) {
+    return (
+      <ChatContextProvider options={options} socketIoUrl={socketIoUrl} getDB={getDB} icon={icon}>
+        <ChatContainer options={options} contacts={contacts}>
+          {children}
+        </ChatContainer>
+      </ChatContextProvider>
+    );
+  } else return (
+    <View style={{padding: 80}}>
+      <Text style={{textAlign: "center"}}>Sorry, you cant use our app without access to you contacts.</Text>
+      <Pressable onPress={() => {
+        Linking.openSettings();
+      }} style={{backgroundColor: "rgb(230,70,30)",borderRadius:5,padding:10,marginTop: 20,}}>
+        <Text style={{color:"white", textAlign: "center",fontSize: 25,fontWeight: "200"}}>Allow Access</Text>
+      </Pressable>
+    </View>
+    
+  )
 }
 
+
+//ChatModule.whyDidYouRender = true;
 ChatModule.propTypes = {
   options: PropTypes.object.isRequired,
   socketIoUrl: PropTypes.string.isRequired,
diff --git a/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js b/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
index 0433613..e624b30 100644
--- a/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
+++ b/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
@@ -3,8 +3,9 @@ import {createKeys, verifyKeys} from "./ChatEncryption";
 SQLite.DEBUG(false);
 SQLite.enablePromise(true);
 let init = false;
+let opening = false;
 let db = null;
-let db_version = 77;
+let db_version = 1;
 export function getEncryptionKeys(context) {
   return new Promise((resolve, reject) => {
     context.getDB().then((db) => {
@@ -49,7 +50,7 @@ function initKeys(token) {
 }
 
 
-function initDB(token) {
+function initDB() {
   //console.warn('initDB');
   /**
      Creating new chat:
@@ -98,7 +99,11 @@ function initDB(token) {
           avatarFileId TEXT,
           avatarPath TEXT,
           phone_number TEXT,
-          seen_at INTEGER
+          seen_at INTEGER,
+          blocked_at INTEGER,
+          muted_at INTEGER,
+          reported_at INTEGER,
+          deleted_at INTEGER
         );`,
     ),
     db.executeSql(
@@ -197,7 +202,7 @@ function initDB(token) {
   ]);
 }
 
-function createOrValidateDB(token) {
+function createOrValidateDB() {
   return new Promise((resolve, reject) => {
     db.transaction((tx) => {
       tx.executeSql(
@@ -205,15 +210,15 @@ function createOrValidateDB(token) {
       ).then(([tx, results]) => {
         const dbCreated = results.rows.item(0).count >= 1;
         if (!dbCreated) {
-          initDB(token).then(() => {
-            initKeys(token).then(() => {
+          initDB().then(() => {
+            //initKeys(token).then(() => {
               resolve();
-            });
+            //});
           });
         } else {
-          initKeys(token).then(() => {
+          //initKeys(token).then(() => {
             resolve();
-          });
+          //});
         }
       }).catch(() => {
         reject();
@@ -226,15 +231,16 @@ function createOrValidateDB(token) {
 
 export function SQLCipherClient(options) {
   return new Promise((resolve, reject) => {
-    if (!db && options) {
+    if (!db && options && !opening) {
+      opening = true;
       SQLite.openDatabase({
-        name: "chat_" + db_version + ".db",
+        name: "chat_" + db_version + "_" + options.id + ".db",
         location: "default",
-        key: options.token.slice(0,10),
+        key: String(options.id),
       }).then(
         (dbInstance) => {
           db = dbInstance;
-          createOrValidateDB(options.token).then(() => {
+          createOrValidateDB().then(() => {
             init = true;
             resolve({database: db});
           }).catch(
