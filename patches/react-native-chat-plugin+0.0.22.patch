diff --git a/node_modules/react-native-chat-plugin/ChatContainer.js b/node_modules/react-native-chat-plugin/ChatContainer.js
index c0d4abb..9a6dbf4 100644
--- a/node_modules/react-native-chat-plugin/ChatContainer.js
+++ b/node_modules/react-native-chat-plugin/ChatContainer.js
@@ -2,116 +2,164 @@ import React from "react";
 import PropTypes from "prop-types";
 import { View, Text, StyleSheet, Alert } from "react-native";
 
-import PhoneContactsScreen from "./PhoneContactsScreen/PhoneContactsScreen";
-import ContactsScreen from "./ContactsScreen/ContactsScreen";
-import { NavigationContainer } from "@react-navigation/native";
-import { createStackNavigator } from "@react-navigation/stack";
 import { ChatContext } from "./ChatContext";
 import { getSocket } from "./utils/SocketIOClient";
-import ChatScreen from "./ChatScreen/ChatScreen";
-import SearchContactsScreen from "./SearchContactsScreen/SearchContactsScreen";
 import PillButton from "./Components/PillButton";
 import Colors from "./constants/Colors";
 import { getEncryptionKeys } from "./utils/SQLCipherClient";
 import { decryptConversations, decryptEvents, recreateEncryptionKeys, resendEncryptionKeys} from "./utils/ChatEncryption";
+import Pressable from "react-native/Libraries/Components/Pressable/Pressable";
+import { responsiveFontSize, responsiveHeight, responsiveWidth } from "react-native-responsive-dimensions";
 
-const Stack = createStackNavigator();
 const styles = StyleSheet.create({
   errorView: {
-    flex: 1,
+    position: "absolute",
     justifyContent: "center",
     padding: 20,
+    flexDirection: "row",
+    top: 3,
+    left: 20,
   },
   errorText: {
     textAlign: "center",
     color: Colors.TEXT,
+    fontSize: 8,
+    marginLeft: 3,
+  },
+  errorIcon: {
+    fontSize: 10,
   },
 });
 
-const defaultOptions = {
-  headerShown: false,
-  cardStyle: {
-    backgroundColor: Colors.BACKGROUND,
-  },
-};
 
-export default function ChatContainer({ options }) {
+
+export default function ChatContainer({ options, children }) {
   const ctx = React.useContext(ChatContext);
   const socket = getSocket();
   const [retry, setRetry] = React.useState(false);
   const [showRetryButton, setShowRetryButton] = React.useState(false);
-  React.useEffect(()=>{
-    ctx.setAuthenticationError("Connecting..");
-  }, []);
-  React.useEffect(() => {
-    const emitEvents = (recreateKeys = false) => {
-      // get all conversations.
-      socket.emit("conversations:fetch", async (res) => {
-        if (res && res.success && Array.isArray(res.conversations)) {
-          const conversations = await decryptConversations(res.conversations, socket.chat_private_key, ctx, recreateKeys);
-          ctx.setConversations(conversations);
-        }
+  const users = ctx.getUsers()
+  const authenticationCallback = (res) => {
+    setTimeout(() => {
+      socket.chat_user_id = res.user.id;
+      /*resendEncryptionKeys(ctx, socket, res.user.id).then(() => {
 
-        socket.emit("events:get_unread_count", ({ success, stats }) => {
-          if (success && stats && Array.isArray(stats) && stats.length > 0) {
-            ctx.updateUnreadCounts({ stats });
+      }).catch((error) => {
+        //console.error('error');
+      });*/
+      /*
+      if (res.user.public_key != socket.chat_public_key) {
+        recreateEncryptionKeys(ctx, socket.chat_token, res.user.salt).then(({ public_key, private_key }) => {
+          if (public_key != res.user.public_key) {
+            socket.chat_public_key = public_key;
+            socket.chat_private_key = private_key;
+            socket.emit("users:updateKey", {public_key});
+            resendEncryptionKeys(ctx, socket, res.user.id).then(() => {
+              emitEvents();
+            }).catch(() => {
+              emitEvents(true);
+            });
+          } else {
+            socket.chat_public_key = public_key;
+            socket.chat_private_key = private_key;
+            emitEvents();
           }
-        });
-      });
-    };
-    const authenticationCallback = (res) => {
-      setTimeout(() => {
-        socket.chat_user_id = res.user.id;
-        /*resendEncryptionKeys(ctx, socket, res.user.id).then(() => {
             
-        }).catch((error) => {
-          //console.error('error');
-        });*/
-        if (res.user.public_key != socket.chat_public_key) {
-          recreateEncryptionKeys(ctx, socket.chat_token, res.user.salt).then(({ public_key, private_key }) => {
-            if (public_key != res.user.public_key) {
-              socket.chat_public_key = public_key;
-              socket.chat_private_key = private_key;
-              socket.emit("users:updateKey", {public_key});
-              resendEncryptionKeys(ctx, socket, res.user.id).then(() => {
-                emitEvents();
-              }).catch(() => {
-                emitEvents(true);
-              });
-            } else {
-              socket.chat_public_key = public_key;
-              socket.chat_private_key = private_key;
-              emitEvents();
+        });
+      } else {
+        emitEvents();
+      }
+      */
+      emitEvents();
+    },100);
+  };
+  React.useEffect(() => {
+    getEncryptionKeys(ctx).then(({ private_key, public_key, salt }) => {
+    socket.chat_public_key = public_key;
+    socket.chat_private_key = private_key;
+    socket.chat_token = options.token;
+    ctx.authenticate({...options,public_key, salt}, authenticationCallback);
+  });
+},[]);
+const emitEvents = (recreateKeys = false) => {
+  // get latest conversations from the server:
+  ctx.getLatestEventFromDB().then((event)=> {
+    const options = event ? {since: 0} : {since: 0};
+    socket.emit("conversations:fetch", options, async (res) => {
+      if (res && res.success && Array.isArray(res.conversations)) {
+        const conversations = await decryptConversations(res.conversations.filter(c => c !== null), socket.chat_private_key, ctx, recreateKeys);
+        ctx.setConversations(conversations);
+        conversations.map(c=>{
+          ctx.saveConversationToDB(c)
+          //console.error(c);
+          c.participants.map(u=>{
+            if (u.id) {
+              ctx.saveUserToDB(u.id, u.avatar, u.username);
+              //console.error(u);
+              ctx.addUser(u);
             }
-            
           });
-        } else {
-          emitEvents();
-        }
-      },10);
-    };
-    getEncryptionKeys(ctx).then(({ private_key, public_key, salt }) => {
-      socket.chat_public_key = public_key;
-      socket.chat_private_key = private_key;
-      socket.chat_token = options.token;
-      ctx.authenticate({...options,public_key, salt}, authenticationCallback);
+        });
+      }
+    });
+  });
+  //get unread count.
+  socket.emit("events:get_unread_count", ({ success, stats }) => {
+    if (success && stats && Array.isArray(stats) && stats.length > 0) {
+      ctx.updateUnreadCounts({ stats });
+    }
+  });
+};
+  React.useEffect(()=>{
+    //ctx.setAuthenticationError("Connecting..");
+  }, []);
+  React.useEffect(() => {
+    // get latest users from the DB:
+    ctx.getUsersFromDB().then((users)=> {
+      for (let i=0;i<users.length;i++) {
+        let user = users.item(i);
+        ctx.addUser(user);
+      }
     });
+    // get latest conversations from the DB:
+    ctx.getConversationsFromDB().then((conversations)=> {
+      for (let i=0;i<conversations.length;i++) {
+        let conversation = conversations.item(i);
+       /* ctx.addConversation({
+          ...conversation, 
+          id: conversation.group_id,
+          time: new Date(conversation.created_at * 1000),
+        });*/
+      }
+    });
+
   
     async function handleEventCreated ({ event }) {
       if (event && event.id) {
         const [decryptedEvent] = await decryptEvents(event.conversationId, [event], socket.chat_private_key, ctx);
-        ctx.addEvent(decryptedEvent);
+        
         if (!event.owner || event.owner.id !== ctx.getUserId()) {
+          ctx.addEvent(decryptedEvent);
           ctx.incrementUnreadCounts(
             { conversationId: event.conversationId, count: 1 }
           );
+          ctx.saveMessageToDB(event.conversationId, event.text, event.owner ? event.owner.id : 0);
+        } else {
         }
+        await ctx.saveUserToDB(event.owner.id, event.owner.avatar, event.owner.username, "");
+      }
+    }
+    async function handleEventRead ({ conversationId, eventId, userId }) {
+      if (conversationId && eventId && userId) {
+        ctx.updateEventReads(conversationId, eventId, userId);
       }
     }
     async function handleConversationCreated({ conversation }) {
       const newConversation = await decryptConversations([conversation], socket.chat_private_key, ctx);
       if (!newConversation[0].hidden) ctx.addConversation(newConversation[0]);
+      ctx.saveConversationToDB(conversation, conversation.name);
     }
+    socket.on("events:read_event", handleEventRead);
     socket.on("events:event_created", handleEventCreated);
     socket.on("conversations:created", handleConversationCreated);
     const cleanAuthenticationHooks = ctx.setUpAuthenticationHooks(authenticationCallback);
@@ -141,29 +189,20 @@ export default function ChatContainer({ options }) {
 
     return () => timer && clearTimeout(timer);
   }, [authError]);
-
+  const Icon = ctx.icon;
   // show authentication error.
   if (authError !== "") {
     return (
-      <View style={styles.errorView}>
-        <Text style={styles.errorText}>
-          Chat error: {authError}
-        </Text>
-        { showRetryButton ? <PillButton text={"Reconnect"} onPress={() => setRetry(!retry)} /> : null }
-      </View>
+      <>
+        {children}
+        { showRetryButton ? <Pressable style={styles.errorView} onPress={() => setRetry(!retry)}><Icon style={styles.errorIcon} name="refreshbold" /><Text style={styles.errorText}>
+          Disconnected
+        </Text></Pressable> : null }
+      </>
     );
   }
 
-  return (
-    <NavigationContainer independent={true}>
-      <Stack.Navigator>
-        <Stack.Screen component={ContactsScreen} name={"ContactsScreen"} options={defaultOptions} />
-        <Stack.Screen component={PhoneContactsScreen} name={"PhoneContactsScreen"} options={defaultOptions} />
-        <Stack.Screen component={ChatScreen} name={"ChatScreen"} options={defaultOptions} />
-        <Stack.Screen component={SearchContactsScreen} name={"SearchContactsScreen"} options={defaultOptions} />
-      </Stack.Navigator>
-    </NavigationContainer>
-  );
+  return (children);
 }
 
 ChatContainer.propTypes = {
diff --git a/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js b/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
index 8e9472a..73e18e5 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/AuthReducer.js
@@ -27,12 +27,11 @@ export function createAuthActions(state, dispatch) {
     if (authenticationTimeout) {
       clearTimeout(authenticationTimeout);
     }
-    // authenticate.
     socket.emit("users:authenticate", options, function handleAuthSuccess(res) {
       if (res && res.success) {
         setAuthInfo(options, res.user);
         setAuthenticationError("");
-        callback(res);
+        if (typeof callback == 'function') callback(res);
       } else {
         setAuthenticationError("Authentication failed!");
       }
@@ -58,10 +57,18 @@ export function createAuthActions(state, dispatch) {
     };
   }
 
-  function createSocketDisconnectedHandler() {
+  function createSocketDisconnectedHandler(callback) {
     return function handleSocketDisconnected(error) {
+      if (authenticationTimeout) {
+        clearTimeout(authenticationTimeout);
+      }
       setAuthenticationError("Lost connection to the server.");
       console.warn("Socket disconnected:", error);
+      if (error == 'ping timeout') {
+        authenticationTimeout = setTimeout(function () {
+          authenticate(state.options, callback);
+        }, 100);
+      }
     };
   }
 
@@ -104,7 +111,7 @@ export function createAuthActions(state, dispatch) {
       const handleRequireAuthentication = createRequireAuthenticationHandler(callback);
       const handleSocketDisconnected = createSocketDisconnectedHandler();
       socket.on('connect', () => {
-        console.log(socket.id); // 'G5p5...'
+        
       });
       // handle connection error.
       socket.on("error", handleSocketError);
diff --git a/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js b/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
index 787b10d..15ddd17 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/ChatReducer.js
@@ -1,10 +1,13 @@
 
 export const ChatInitialState = {
   conversations: [],
+  calls: [],
   authenticationError: "",
   loading: false,
   options: {},
   user: {},
+  users: [],
+  contacts: [],
 };
 
 export function ChatReducer(state, action) {
@@ -20,6 +23,39 @@ export function ChatReducer(state, action) {
     return { ...state, conversations };
   }
 
+  case "update_event": {
+    const { conversationId, nonce, event} = action.payload;
+    const conversationIdx = state.conversations.findIndex((c) => c.id === conversationId);
+    if (conversationIdx == -1) return state;
+    const conversations = [...state.conversations];
+    const eventsIdx =  conversations[conversationIdx].events.findIndex((c) => c.id == nonce);
+    conversations[conversationIdx].lastEvent = event
+    if (eventsIdx == -1) {
+      conversations[conversationIdx].events.push(event);
+      return { ...state, conversations };
+    }
+    conversations[conversationIdx].events[eventsIdx] = event;
+    return { ...state, conversations };
+  }
+
+  case "update_event_reads": {
+    const { conversationId, eventId, userId} = action.payload;
+    const conversationIdx = state.conversations.findIndex((c) => c.id === conversationId);
+    if (conversationIdx == -1) return state;
+    const conversations = [...state.conversations];
+    if (typeof conversations[conversationIdx] == 'object' &&  typeof conversations[conversationIdx].events == 'undefined') return state;
+    const eventsIdx =  conversations[conversationIdx].events.findIndex((c) => c.id == eventId);
+    if (eventsIdx == -1) return state;
+    const event = conversations[conversationIdx].events[eventsIdx];
+    const readBy = typeof event.readBy == 'undefined' ? [] : event.readBy;
+    readBy.push(userId);
+    conversations[conversationIdx].events[eventsIdx] = {
+      ...event,
+      readBy: readBy
+    };
+    return { ...state, conversations };
+  }
+
   case "new_event": {
     const event = action.payload.event;
     const conversationId = event.conversationId || event.conversation.id;
@@ -30,7 +66,11 @@ export function ChatReducer(state, action) {
     const conversationIdx = state.conversations.findIndex((c) => c.id === conversationId);
     const conversations = [...state.conversations];
     if (conversations[conversationIdx]) {
-      conversations[conversationIdx].lastEvent = event;
+      if (!conversations[conversationIdx].lastEvent || typeof conversations[conversationIdx].lastEvent.created_at == 'undefined') {
+        conversations[conversationIdx].lastEvent = event;
+      } else if (conversations[conversationIdx].lastEvent.created_at < event.created_at) {
+        conversations[conversationIdx].lastEvent = event;
+      }
       if (Array.isArray(conversations[conversationIdx].events)) {
         conversations[conversationIdx].events.push(event);
       }
@@ -54,6 +94,12 @@ export function createChatActions(state, dispatch) {
     addEvent(event) {
       dispatch({ type: "new_event", payload: { event } });
     },
+    updateEvent(conversationId, nonce, event) {
+      dispatch({ type: 'update_event', payload: {conversationId, nonce, event}});
+    },
+    updateEventReads(conversationId, eventId, userId) {
+      dispatch({ type: 'update_event_reads', payload: {conversationId, eventId, userId}});
+    },
     setEvents({ conversationId, events }) {
       dispatch({ type: "update_events", payload: { conversationId, events }});
     },
diff --git a/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js b/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
index c41797c..85e23c8 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/ConversationReducer.js
@@ -1,3 +1,5 @@
+import React from "react";
+import { ChatContext } from "react-native-chat-plugin/ChatContext";
 import { getSocket } from "../utils/SocketIOClient";
 
 const addConversations = (state, conversations) => {
@@ -16,6 +18,24 @@ const addConversations = (state, conversations) => {
   return { ...state, conversations: newConversations };
 };
 
+const addCalls = (state, calls) => {
+  const newCalls = [...state.calls];
+  for (const call of calls) {
+    const callIdx = newCalls.findIndex((c) => c.id === call.id);
+    if (callIdx === -1) {
+      newCalls.unshift(call);
+    } else {
+      newCalls[callIdx] = {
+        ...newCalls[callIdx],
+        ...call
+      };
+    }
+  }
+  return { ...state, calls: newCalls };
+};
+
+
+
 const updateUnreadCounts = (state, stats) => {
   const newConversations = [...state.conversations];
   for (const stat of stats) {
@@ -51,7 +71,7 @@ const setTyping = (state, conversationId, userId) => {
     newConversations[conversationIdx].typing = {};
   }
   if (!(userId in newConversations[conversationIdx].typing)) {
-    newConversations[conversationIdx].typing = {userId, timestamp};
+    newConversations[conversationIdx].typing[userId] = {userId, timestamp};
   }
   return { ...state, conversations: newConversations };
 };
@@ -74,6 +94,24 @@ const unsetTyping = (state, conversationId, userId) => {
 
 export function conversationReducer(state, action) {
   switch(action.type) {
+  case "add_user": {
+    // delete conversation by id.
+    const user = action.payload.user;
+    const users = [...state.users];
+    const userIdx = state.users.findIndex(u => u.userId === user.userId);
+    if (userIdx != -1) {
+      users[userIdx] = user;
+    } else {
+      users.push(user);
+    }
+    return { ...state, users };
+  }
+  case "delete_call": {
+    const callId = action.payload.call.id;
+    const calls = state.calls.filter(call => call.id !== callId);
+    return { ...state, calls };
+  }
+
   case "delete_conversation": {
     // delete conversation by id.
     const conversationId = action.payload.conversationId;
@@ -82,22 +120,63 @@ export function conversationReducer(state, action) {
   }
 
   case "mute_conversation": {
-    // delete conversation by id.
+    // mute conversation by id.
+    const conversationId = action.payload.conversationId;
+    const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, muted: !conversation.muted});
+    return { ...state, conversations };
+  }
+
+  case "archive_conversation": {
+    // archive conversation by id.
+    const conversationId = action.payload.conversationId;
+    const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, archived: !conversation.archived});
+    return { ...state, conversations };
+  }
+
+  case "pin_conversation": {
+    // pin conversation by id.
+    const conversationId = action.payload.conversationId;
+    const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, pinned: !conversation.pinned});
+    return { ...state, conversations };
+  }
+
+  case "unread_conversation": {
+    // unread conversation by id.
+    const conversationId = action.payload.conversationId;
+    const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, unread: !conversation.unread});
+    return { ...state, conversations };
+  }
+
+  case "mute_conversation": {
+    // mute conversation by id.
     const conversationId = action.payload.conversationId;
     const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, muted: !conversation.muted});
     return { ...state, conversations };
   }
 
+  case "typing_conversation": {
+    // set typing flag conversation by id.
+    const conversationId = action.payload.conversationId;
+    const conversations = state.conversations.map(conversation => conversation.id !== conversationId ? conversation : {...conversation, typing: !conversation.typing});
+    return { ...state, conversations };
+  }
+
   case "update_conversations":
     return { ...state, conversations: action.payload.conversations };
 
   case "add_conversations": {
     return addConversations(state, action.payload.conversations);
   }
+  case "add_calls": {
+    return addCalls(state, action.payload.calls);
+  }
 
   case "add_conversation": {
     return addConversations(state, [action.payload.conversation]);
   }
+  case "add_call": {
+    return addCalls(state, [action.payload.call]);
+  }
 
   case "update_unread_counts": {
     return updateUnreadCounts(state, action.payload.stats);
@@ -120,11 +199,14 @@ export function conversationReducer(state, action) {
 
 export function createConversationActions(state, dispatch) {
   const socket = getSocket();
-
   function deleteConversation(conversationId, hidden) {
+    dispatch({ type: "delete_conversation", payload: { conversationId }});
+    const ctx = this;
     socket.emit("conversations:delete", { conversationId, hidden }, function (res) {
       if (res && res.success) {
-        dispatch({ type: "delete_conversation", payload: { conversationId }});
+        ctx.removeConversationFromDB(conversationId);
+      } else {
+        ctx.removeConversationFromDB(conversationId);
       }
     });
   }
@@ -132,11 +214,60 @@ export function createConversationActions(state, dispatch) {
     dispatch({ type: "mute_conversation", payload: { conversationId }});
   }
 
+  function pinConversation(conversationId) {
+    dispatch({ type: "pin_conversation", payload: { conversationId }});
+  }
+
+  function unreadConversation(conversationId) {
+    dispatch({ type: "unread_conversation", payload: { conversationId }});
+  }
+
+  function archiveConversation(conversationId) {
+    dispatch({ type: "archive_conversation", payload: { conversationId }});
+  }
   return {
     deleteConversation,
     muteConversation,
+    pinConversation,
+    unreadConversation,
+    archiveConversation,
+    getCallname(conversationId) {
+      const ctx = this;
+      const conversationIdx = state.conversations.findIndex(c => c.id == conversationId);
+      return ctx.getChatname(state.conversations[conversationIdx]);
+    },
+    getChatname(conversation) {
+      const user = state.user;
+      if (!conversation) return "";
+      if (typeof conversation.participants !== "undefined" && (conversation.name == "" || !conversation.name)) {
+        const notOwner = conversation.participants.filter(f=>f.id !== user.id)
+        const name = notOwner[0] ? this.getContactName(notOwner[0].username) : "Me";
+        return name;
+      } return conversation.name;
+    },
+    getContactName(phone_number) {
+      const ctx = this;
+      const contactIdx = ctx.contacts.findIndex(c => c.labels.indexOf(phone_number) !== -1);
+      return contactIdx !== -1 ? ctx.contacts[contactIdx].value : (state.user.username !== phone_number && phone_number != 'Me' ? phone_number : "Me");
+    },
+    getUsernameByUserId(userId) {
+      const users = state.users;
+      const userIdx = state.users.findIndex(u => u.userId == userId);
+      return userIdx !== -1 ? this.getContactName(users[userIdx].username) : `Wevive user`; 
+    },
+    getUsers() {
+      return state.users || [];
+    },
+    getCalls() {
+      return state.calls ? state.calls.sort((a,b)=>{
+        if (a.created_at && b.created_at) {
+          return a.created_at < b.created_at;
+        }
+      }) : [];
+    },
     getConversations() {
       state.conversations.sort((a,b)=>{
+        if (a.pinned && !b.pinned) return false;
         if (a.lastEvent && b.lastEvent) {
           return a.lastEvent.time < b.lastEvent.time;
         } else if (a.lastEvent) {
@@ -152,6 +283,9 @@ export function createConversationActions(state, dispatch) {
         dispatch({ type: "add_conversations", payload: { conversations }});
       }
     },
+    addUser(user) {
+      dispatch({ type: "add_user", payload: { user }});
+    },
     addConversation(conversation) {
       dispatch({ type: "add_conversation", payload: { conversation }});
     },
@@ -167,5 +301,8 @@ export function createConversationActions(state, dispatch) {
     unsetTyping({ conversationId, userId }) {
       dispatch({ type: "unset_typing", payload: { conversationId, userId }});
     },
+    addCalls(calls) {
+      dispatch({ type: "add_calls", payload: { calls }});
+    },
   };
 }
diff --git a/node_modules/react-native-chat-plugin/ChatContext/index.js b/node_modules/react-native-chat-plugin/ChatContext/index.js
index f9bc1dc..ce7a152 100644
--- a/node_modules/react-native-chat-plugin/ChatContext/index.js
+++ b/node_modules/react-native-chat-plugin/ChatContext/index.js
@@ -6,7 +6,8 @@ import combineReducers from "./combineReducers";
 import { authReducer, createAuthActions } from "./AuthReducer";
 import { createConversationActions, conversationReducer } from "./ConversationReducer";
 import { createSettingsActions, settingsReducer } from "./SettingsReducer";
-
+import { SHA512 } from "crypto-js";
+import RNFS from 'react-native-fs';
 
 export const ChatContext = React.createContext({...ChatInitialState});
 
@@ -17,8 +18,452 @@ const reducer = combineReducers(
   settingsReducer
 );
 
-export function ChatContextProvider({options,children,socketIoUrl, db, icon, contacts}) {
+export function ChatContextProvider({options,children,socketIoUrl, getDB, icon, contacts}) {
   const [state, dispatch] = React.useReducer(reducer, ChatInitialState);
+  const removeFolderFromDisk = React.useCallback((type) => {
+    return new Promise((resolve, reject) => {
+      //TODO: remove folder from disk
+    });
+  });
+  const removeFiles = React.useCallback((type) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "UPDATE files SET path=?",[""]
+        ).then(([results])=> {
+          removeFolderFromDisk(type).then(() => {
+            resolve(results);
+          });
+        });
+      })
+    });
+  },[]);
+  const removeConversationsFromDB = React.useCallback((conversationId) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "DELETE FROM messages"
+        ).then(([results])=> {
+          if (withConversations) {
+            db.executeSql(
+              "DELETE FROM conversations"
+            ).then(([results])=> {
+              resolve(results);
+            });
+          } else {
+            resolve(results);
+          }
+        });
+      })
+    });
+  },[]);
+  const deleteCall = React.useCallback((call) => {
+    dispatch({ type: "delete_call", payload: { call }});
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "DELETE FROM calls WHERE id = ?",
+          [call.id]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const removeConversationFromDB = React.useCallback((conversationId) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "DELETE FROM conversations WHERE group_id = ?",
+          [conversationId]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const getSettings = React.useCallback((name, settings) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM settings WHERE name=?", [name]
+        ).then(([results])=> {
+          resolve(results);
+        })
+      });
+    });
+  });
+  const updateSettings = React.useCallback((name, settings) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "INSERT OR IGNORE INTO settings (`name`) VALUES (?)",
+          [name]
+        ).then(() => {
+          db.executeSql(
+            "SELECT * FROM settings WHERE name=?", [name]
+          ).then(([results])=> {
+            //TODO: Merge results and passed settings
+            db.executeSql(
+              "UPDATE settings SET `settings`=? WHERE name = ?",
+              [value, conversationId]
+            ).then(([results])=> {
+              resolve(results);
+            });
+          })
+        })
+      })
+    });
+  },[]);
+  const markConversation = React.useCallback((conversationId, type, value) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "UPDATE conversations SET `is_"+type+"`=? WHERE group_id = ?",
+          [value, conversationId]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const updateMessageEvent = React.useCallback((messageId, eventId) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "UPDATE messages SET `event_id`=? WHERE id = ?",
+          [eventId, messageId]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const markMessage = React.useCallback((messageId, type, value) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "UPDATE conversations SET `is_"+type+"`=? WHERE id = ?",
+          [value, messageId]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const updateLastSeen = React.useCallback((userId) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "UPDATE users SET `seen_at`=? WHERE userId = ?",
+          [Math.floor(Date.now() / 1000), userId]
+        ).then(([results])=> {
+          resolve(results);
+        });
+      })
+    });
+  },[]);
+  const getCallsFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM calls ORDER BY created_at DESC"
+        ).then(([results])=> {
+          if (results.rows.length > 0) {
+            phoneCalls = [];
+            for (let i=0; i<results.rows.length; i++) {
+              const phoneCall = results.rows.item(i);
+              phoneCalls.push({
+                ...phoneCall,
+                created_at: phoneCall.created_at * 1000,
+              });
+            }
+            resolve(phoneCalls)
+          } else {
+            resolve([]);
+          }
+        });
+      })
+    });
+  },[]);
+  const getGroupsFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM groups ORDER BY created_at DESC"
+        ).then(([results])=> {
+          if (results.rows.length > 0) {
+            groups = [];
+            for (let i=0; i<results.rows.length; i++) {
+              const group = results.rows.item(i);
+              groups.push({
+                ...group,
+                created_at: group.created_at * 1000,
+              });
+            }
+            resolve(groups)
+          } else {
+            resolve([]);
+          }
+        });
+      })
+    });
+  },[]);
+  const getPostsFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM posts ORDER BY created_at DESC"
+        ).then(([results])=> {
+          if (results.rows.length > 0) {
+            posts = [];
+            for (let i=0; i<results.rows.length; i++) {
+              const post = results.rows.item(i);
+              posts.push({
+                ...post,
+                created_at: post.created_at * 1000,
+              });
+            }
+            resolve(posts)
+          } else {
+            resolve([]);
+          }
+        });
+      })
+    });
+  },[]);
+  const getUsersFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM users ORDER BY created_at DESC"
+        ).then(([results])=> {
+          resolve(results.rows.length > 0 ? results.rows : false);
+        });
+      })
+    });
+  },[]);
+  const getConversationsFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM conversations ORDER BY created_at DESC"
+        ).then(([results])=> {
+          
+          resolve(results.rows.length > 0 ? results.rows : false);
+        });
+      })
+    });
+  },[]);
+  const getMessagesFromDB = React.useCallback((conversationId) => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT * FROM messages WHERE group_id = ? ORDER BY created_at DESC",
+          [conversationId]
+        ).then(([results])=> {
+          if (results.rows.length > 0) {
+            messages = [];
+            for (let i=0; i<results.rows.length; i++) {
+              const message = results.rows.item(i);
+              messages.push({
+                ...message,
+                created_at: message.created_at * 1000,
+              });
+            }
+            resolve(messages)
+          } else {
+            resolve([]);
+          }
+        });
+      })
+    });
+  },[]);
+  const getLatestEventFromDB = React.useCallback(() => {
+    return new Promise((resolve, reject) => {
+      return getDB().then((db)=> {
+        db.executeSql(
+          "SELECT created_at FROM messages UNION ALL SELECT created_at FROM conversations ORDER BY created_at DESC"
+        ).then(([results])=> {
+          resolve(results.rows.length > 0 ? results.rows.item(0).created_at : 0);
+        });
+      })
+    });
+  },[]);
+  const _saveFileToDisk = React.useCallback((url, path) => {
+    return new Promise((resolve, reject) => {
+      if (url == null || !url) {
+        resolve("");
+        return;
+      }
+      const destPath = RNFS.DocumentDirectoryPath + '/' + path;
+      
+      let option = {
+        fromUrl: url,
+        toFile: destPath
+      };
+      RNFS.downloadFile(option).promise.then(res => {
+        resolve(res);
+      });
+    });
+  });
+  const saveFileToDisk = React.useCallback((url, filetype) => {
+    return new Promise(async (resolve, reject) => {
+      if (!url) {
+        resolve("");
+        return;
+      }
+      const path = filetype + "/" + SHA512(url);
+      const dirExists = await RNFS.exists(RNFS.DocumentDirectoryPath + '/' + filetype);
+      if (!dirExists) {
+        await RNFS.mkdir(RNFS.DocumentDirectoryPath + '/' + filetype);
+      }
+      const fileExists = await RNFS.exists(RNFS.DocumentDirectoryPath + '/' + path);
+      if (fileExists !== false) {
+        resolve(RNFS.DocumentDirectoryPath + '/' + path);
+      } else { 
+        _saveFileToDisk(url, path, filetype).then(()=>{
+          resolve(RNFS.DocumentDirectoryPath + '/' + path);
+        });
+      }
+    });
+  },[]);
+
+  const getFileSize = React.useCallback(async (path) => {
+    const stat = await RNFS.stat(path);
+    if (stat.isFile()) {
+      return stat.size;
+    }
+    return -1;
+  },[]);
+
+  const saveFile = React.useCallback((url, filetype, refId) => {
+    return new Promise(async (resolve, reject) => {
+      if (!url || url == '') {
+        resolve("0");
+        return;
+      }
+      const path = await saveFileToDisk(url, filetype);
+      if (!path || path == "") {
+        resolve("0");
+        return;
+      }
+      const size = await getFileSize(path);
+      if (size == '0' || size < 0) {
+        resolve("0");
+        return;
+      }
+      getDB().then((db)=> {
+        return db.executeSql(
+          "SELECT id FROM files WHERE path = ?",
+          [path]
+        ).then(([results])=> {
+          const alreadyExists = results.rows.length > 0 ? results.rows.item(0).id : false;
+          const contents = "";
+          if (alreadyExists) {
+            resolve(results.rows.item(0).id);
+          } else {
+            return db.executeSql(
+              "INSERT OR IGNORE INTO files (`url`,`type`, `path` ,`size`,`contents`, `refId`, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
+              [url, filetype, path, size, refId, contents, Math.floor(Date.now() / 1000)]
+            ).then(([results])=> {
+              resolve(results.insertId);
+            });
+          }
+        });
+      })
+    });
+  },[]);
+  const saveCallToDB = React.useCallback((conversation, created_by) => {
+    getDB().then((db)=> {
+      db.executeSql(
+        "INSERT OR IGNORE INTO calls(`group_id`,`name`,`created_by`, created_at) VALUES (?, ?, ?, ?)",
+        [conversation.id, conversation.name, created_by, Math.floor(Date.now() / 1000)]
+      ).then(([results])=> {
+        return results;
+      });
+    })
+  },[]);
+  const updateCallDuration = React.useCallback((call_id, duration, bytes_total, bytes_incoming, bytes_outgoing) => {
+    getDB().then((db)=> {
+      db.executeSql(
+        "UPDATE calls(`duration`, `bytes_total`, `bytes_incoming`, `bytes_outgoing`) VALUES (?, ?, ?, ?) WHERE id=?",
+        [duration, call_id, bytes_total ? bytes_total : 0, bytes_incoming ? bytes_incoming : 0, bytes_outgoing ? bytes_outgoing :0]
+      ).then(([results])=> {
+        return results;
+      });
+    })
+  },[]);
+  const saveUserToDB = React.useCallback((userId, avatarUrl, username, phone_number) => {
+    return new Promise((resolve, reject) => {
+      getDB().then(async (db)=> {
+        const existingUser = await db.executeSql(
+          "SELECT * FROM users WHERE userId = ? ORDER BY created_at DESC",
+          [userId]
+        );
+        if (existingUser[0].rows.length > 0) {
+          const avatarFileId = avatarUrl !== null ? await saveFile(avatarUrl,'avatar',userId) : existingUser[0].rows.item(0).avatarFileId;
+          const avatar = avatarUrl !== null ? avatarUrl : existingUser[0].rows.item(0).avatarUrl;
+          const update = await db.executeSql(
+            "UPDATE users SET username=?, avatarUrl=?, avatarFileId=?, phone_number=? WHERE userId=?",
+            [ username, avatarUrl, avatarFileId, phone_number, userId]
+          );
+        } else {
+          const avatarFileId = avatarUrl !== null ? await saveFile(avatarUrl,'avatar',userId) : 0;
+          return await db.executeSql(
+            "INSERT OR IGNORE INTO users (`userId`,`username`,`avatarUrl`, `avatarFileId`, `phone_number`, created_at) VALUES (?, ?, ?, ?, ?, ?)",
+            [userId, username, avatarUrl, avatarFileId, phone_number, Math.floor(Date.now() / 1000)]
+          );
+        }
+      })
+    });
+  },[]);
+  const saveMessageToDB = React.useCallback((conversation, contents, author, event_id) => {
+    return getDB().then((db)=> {
+      return db.executeSql(
+        "INSERT OR IGNORE INTO messages(`group_id`,`text`,`author_id`, `event_id`, created_at) VALUES (?, ?, ?, ?, ?)",
+        [conversation.id, contents, author, event_id, Math.floor(Date.now() / 1000)]
+      ).then(([results])=> {
+        return results.insertId;
+      });
+    })
+  },[]);
+  const saveConversationToDB = React.useCallback((conversation) => {
+    getDB().then((db)=> {
+      db.executeSql(
+        "INSERT OR IGNORE INTO conversations(`group_id`,`group_key`,`name`,`created_by`,`created_at`) VALUES (?, ?, ?, ?, ?)",
+        [conversation.id, "", conversation.name, conversation.participants[conversation.participants.length-1].id, Math.floor(Date.now() / 1000)]
+      ).then(([results])=> {
+        conversation.participants.map(p =>  
+          db.executeSql(
+            "INSERT OR IGNORE INTO participants(`group_id`,`user_id`, `created_at`) VALUES (?, ?, ?)",
+            [conversation.id, p.id, Math.floor(Date.now() / 1000)]
+          )
+        );
+        return results;
+      });
+    })
+  },[]);
+  const savePostToDB = React.useCallback((conversation, name) => {
+    getDB().then((db)=> {
+      db.executeSql(
+        "INSERT OR IGNORE INTO conversations(`group_id`,`group_key`,`name`,`created_by`,`created_at`) VALUES (?, ?, ?, ?, ?)",
+        [conversation.id, "", conversation.name, conversation.participants[conversation.participants.length-1].id, Math.floor(Date.now() / 1000)]
+      ).then(([results])=> {
+        return results;
+      });
+    })
+  },[]);
+  const saveGroupToDB = React.useCallback((conversation, name) => {
+    getDB().then((db)=> {
+      db.executeSql(
+        "INSERT OR IGNORE INTO conversations(`group_id`,`group_key`,`name`,`created_by`,`created_at`) VALUES (?, ?, ?, ?, ?)",
+        [conversation.id, "", conversation.name, conversation.participants[conversation.participants.length-1].id, Math.floor(Date.now() / 1000)]
+      ).then(([results])=> {
+        return results;
+      });
+    })
+  },[]);
   const context = React.useMemo(
     () => {
       return ({
@@ -26,11 +471,33 @@ export function ChatContextProvider({options,children,socketIoUrl, db, icon, con
         ...createAuthActions(state, dispatch),
         ...createChatActions(state, dispatch),
         ...createConversationActions(state, dispatch),
-        getDB() {
-          return db;
-        },
+        getDB,
         contacts,
-        icon
+        icon,
+        saveMessageToDB,
+        saveConversationToDB,
+        getLatestEventFromDB,
+        getConversationsFromDB,
+        getMessagesFromDB,
+        markConversation,
+        removeConversationFromDB,
+        updateMessageEvent,
+        getSettings,
+        updateSettings,
+        saveCallToDB,
+        updateCallDuration,
+        saveUserToDB,
+        getCallsFromDB,
+        getUsersFromDB,
+        updateLastSeen,
+        removeConversationsFromDB,
+        removeFiles,
+        savePostToDB,
+        saveGroupToDB,
+        getPostsFromDB,
+        getGroupsFromDB,
+        deleteCall,
+        markMessage,
       });
     },
     [state]
@@ -47,5 +514,5 @@ ChatContextProvider.propTypes = {
   options: PropTypes.object.isRequired,
   children: PropTypes.element.isRequired,
   socketIoUrl: PropTypes.string.isRequired,
-  db: PropTypes.object.isRequired,
+  getDB: PropTypes.func.isRequired,
 };
diff --git a/node_modules/react-native-chat-plugin/ChatNavigation.js b/node_modules/react-native-chat-plugin/ChatNavigation.js
new file mode 100644
index 0000000..871a1d3
--- /dev/null
+++ b/node_modules/react-native-chat-plugin/ChatNavigation.js
@@ -0,0 +1,8 @@
+import * as React from 'react';
+
+export const navigationRef = React.createRef();
+
+export function navigate(name, params) {
+  //console.warn(navigationRef.current);
+  navigationRef.current?.navigate(name, params);
+}
\ No newline at end of file
diff --git a/node_modules/react-native-chat-plugin/ChatNavigator.js b/node_modules/react-native-chat-plugin/ChatNavigator.js
new file mode 100644
index 0000000..609e264
--- /dev/null
+++ b/node_modules/react-native-chat-plugin/ChatNavigator.js
@@ -0,0 +1,30 @@
+import React from "react";
+import PhoneContactsScreen from "./PhoneContactsScreen/PhoneContactsScreen";
+import ContactsScreen from "./ContactsScreen/ContactsScreen";
+import ChatScreen from "./ChatScreen/ChatScreen";
+import SearchContactsScreen from "./SearchContactsScreen/SearchContactsScreen";
+
+import { NavigationContainer } from "@react-navigation/native";
+import { createStackNavigator } from "@react-navigation/stack";
+import Colors from "./constants/Colors";
+import ChatScreen from "./ChatScreen/ChatScreen";
+import SearchContactsScreen from "./SearchContactsScreen/SearchContactsScreen";
+
+import navigationRef from './ChatNavigation';
+import { stubFalse } from "lodash";
+const defaultOptions = {
+    headerShown: false,
+    cardStyle: {
+      backgroundColor: Colors.BACKGROUND,
+    },
+};
+const Stack = createStackNavigator();
+
+export default function ChatNavigator() {
+    return <Stack.Navigator screenOptions={{gestureEnabled: false}}>
+        <Stack.Screen component={ContactsScreen} name={"ContactsScreen"} options={defaultOptions} />
+        <Stack.Screen component={PhoneContactsScreen} name={"PhoneContactsScreen"} options={defaultOptions} />
+        <Stack.Screen component={ChatScreen} name={"ChatScreen"} options={defaultOptions} />
+        <Stack.Screen component={SearchContactsScreen} name={"SearchContactsScreen"} options={defaultOptions} />
+    </Stack.Navigator>
+}
\ No newline at end of file
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js b/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
index 5388ef0..f68395d 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/ChatForm.js
@@ -10,7 +10,7 @@ import {encryptChatMessage} from "../utils/ChatEncryption";
 import {launchCamera, launchImageLibrary} from "react-native-image-picker";
 
 import WebView from "react-native-webview";
-import Recording from "react-native-recording";
+//import Recording from "react-native-recording";
 
 const sendButton = require("../images/sendbtn.png");
 const styles = StyleSheet.create({
@@ -135,9 +135,8 @@ export default function ChatForm({ conversation }) {
   const onChangeText = React.useCallback((text) => {
     setMessage(text);
     const socket = getSocket();
-    if (settings.disable_typing_events) {
+    if (!settings.disable_typing_events) {
       socket.emit("events:typing", { conversationId: conversation.id }, ({ success, error }) => {
-        i = i + 1;
         if (!success && error) {
           Alert.alert("Error", error);
         }
@@ -145,24 +144,42 @@ export default function ChatForm({ conversation }) {
     }
   },[message]);
 
-  const sendMessage = React.useCallback((contents) => {
+  const sendMessage = React.useCallback(async (contents) => {
     const socket = getSocket();
-    socket.emit("events:new_message", { conversationId: conversation.id, message: contents }, ({ success, error }) => {
-      if (!success && error) {
-        if (tries >= maxRetries) {
-          Alert.alert("Error", error);
-          //TODO add to the database and try to resend later;
-        } else {
-          setTries(tries + 1);
-          setTimeout(()=>{
-            sendMessage(contents);
-          }, 1000 * (1+tries * 2));
+    setMessage("");
+    const localMsg = await ctx.saveMessageToDB(conversation, contents, socket.chat_user_id, 0);
+    const newMessage = {
+      id: String(localMsg),
+      conversationId: conversation.id,
+      type: "MESSAGE",
+      nonce: localMsg,
+      owner: {
+        id: socket.chat_user_id,
+        username: "Me",
+      },
+      time: +Date.now(), 
+      text: contents,
+    };
+    ctx.addEvent(newMessage);
+    setTimeout(()=>{
+      socket.emit("events:new_message", { conversationId: conversation.id, message: contents, nonce: localMsg }, ({ success, error, event, nonce }) => {
+        if (!success && error) {
+          if (tries >= maxRetries) {
+            Alert.alert("Error", "Failed to send message");
+          } else {
+            setTries(tries + 1);
+            setTimeout(()=>{
+              sendMessage(contents);
+            }, 1000 * (1+tries * 2));
+          }
+        } else if (event) {
+          ctx.updateEvent(conversation.id, localMsg, event)
+          ctx.updateMessageEvent(localMsg, event)
         }
-      }
-    });
+      });
+    },1000)
   },[]);
   const submit = React.useCallback(() => {
-    setMessage("");
     if (message) {
       ctx.getDB().then((db)=> {
         db.executeSql(
@@ -177,7 +194,11 @@ export default function ChatForm({ conversation }) {
           } else {
             sendMessage(message);
           }
+        }).catch((e) => {
+          console.warn(e);
         });
+      }).catch((e)=>{
+        console.warn(e);
       });
       
       Keyboard.dismiss();
@@ -193,7 +214,7 @@ export default function ChatForm({ conversation }) {
 
     });
   };
-  Recording.stop();
+  //Recording.stop();
 
   const [audioWebview, setWebView] = React.useState(false);
   const [audioLoaded, setAudioLoaded] = React.useState(false);
@@ -203,12 +224,12 @@ export default function ChatForm({ conversation }) {
   const recordAudio = () => {
     if (audioRecording) {
       setAudioRecording(false);
-      Recording.stop();
+      //Recording.stop();
       if (this.listener) this.listener.remove();
       return;
     }
     setAudioRecording(true);
-    Recording.init({
+    /*Recording.init({
       bufferSize: 81920,
       sampleRate: 44100,
       bitsPerChannel: 8,
@@ -227,15 +248,28 @@ export default function ChatForm({ conversation }) {
     });
 
     Recording.start();
+    */
   };
-  
+  /*const microphoneIcon = <TouchableOpacity onPress={recordAudio} style={styles.micBtn}>
+    <Icon name="microphone" style={audioRecording ? styles.activeMicIcon : styles.micIcon} />
+  </TouchableOpacity>;*/
+  /*
+  const galleryButtons = <TouchableOpacity style={styles.btnIcon} onPress={openCamera}>
+        <Icon name="camera" style={styles.btnIconStyles} />
+      </TouchableOpacity>
+      <TouchableOpacity style={styles.btnImage} onPress={openImageGallery}>
+        <Image source={imageIcon} style={styles.btnImageStyles} />
+      </TouchableOpacity>
+  */
+  const microphoneIcon = null;
+  const galleryButtons = null;
   return (
     <View style={styles.container}>
       <Image source={messageIcon} style={styles.messageIcon} />
       <TextInput
         textAlignVertical={"top"}
         numberOfLines={5}
-        multiline={true}
+        multiline={false}
         value={message}
         style={styles.txt}
         onSubmitEditing={submit}
@@ -243,19 +277,11 @@ export default function ChatForm({ conversation }) {
         placeholderTextColor={"rgb(125,125,125)"}
         blurOnSubmit={true}
         onChangeText={onChangeText} />
-      <AudioRecord setWebView={setWebView} setLoading={setAudioLoaded}/>
-      <TouchableOpacity onPress={recordAudio} style={styles.micBtn}>
-        <Icon name="microphone" style={audioRecording ? styles.activeMicIcon : styles.micIcon} />
-      </TouchableOpacity>
+      {microphoneIcon}
       <TouchableOpacity style={styles.btnImage} onPress={submit}>
         <Image source={sendButton} style={styles.btnImageStyles} />
       </TouchableOpacity>
-      <TouchableOpacity style={styles.btnIcon} onPress={openCamera}>
-        <Icon name="camera" style={styles.btnIconStyles} />
-      </TouchableOpacity>
-      <TouchableOpacity style={styles.btnImage} onPress={openImageGallery}>
-        <Image source={imageIcon} style={styles.btnImageStyles} />
-      </TouchableOpacity>
+      {galleryButtons}
     </View>
   );
 }
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js b/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
index bbdff8a..98a0443 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/ChatScreen.js
@@ -1,5 +1,5 @@
 import React from "react";
-import { View, StyleSheet, KeyboardAvoidingView, ImageBackground, Platform } from "react-native";
+import { View, StyleSheet, Alert, KeyboardAvoidingView, ImageBackground, Platform, Text } from "react-native";
 import PropTypes from "prop-types";
 import Header from "../Components/Header";
 import ChatForm from "./ChatForm";
@@ -13,6 +13,12 @@ import { useSafeArea } from "react-native-safe-area-context";
 import {decryptEvents} from "../utils/ChatEncryption";
 import TypingIndicator from "./TypingIndicator";
 import { TouchableOpacity } from "react-native-gesture-handler";
+import Pressable from "react-native/Libraries/Components/Pressable/Pressable";
+
+import Clipboard from "@react-native-clipboard/clipboard";
+import {captureRef} from "react-native-view-shot";
+import Share from "react-native-share";
+
 const styles = StyleSheet.create({
   container: {
     flex: 1,
@@ -30,8 +36,95 @@ const styles = StyleSheet.create({
   wallpaper: {
     width: "100%",
     height: "100%"
+  },
+  buttons: {
+    marginVertical: 10,
+    flexDirection: "row",
+    marginRight: 10,
+  },
+  button: {
+    backgroundColor: "rgb(242,142,62)",
+    borderRadius: 24,
+    padding: 3,
+    marginRight: 15,
+  },
+  callIcon: {
+    fontSize: 35,
+    color: "white",
+  },
+  videoCallIcon: {
+    fontSize: 35,
+    color: "white",
+  },
+  menuBox: {
+    position: "absolute",
+    backgroundColor: "#333",
+    borderRadius: 20,
+    zIndex: 999,
+    right: 20,
+    paddingVertical: 5,
+  },
+  ownMenuBox: {
+    position: "absolute",
+    backgroundColor: "#333",
+    borderRadius: 20,
+    left: 10,
+    paddingVertical: 5,
+    zIndex: 999,
+  },
+  menuText: {
+    color: "white",
+    fontSize: 12,
+  },
+  menuButton: {
+    marginVertical: 7,
+    paddingBottom: 15,
+    paddingHorizontal: 20,
+    zIndex: 999,
+    flexDirection: "row",
+    justifyContent: "space-between",
+    borderBottomColor: "white",
+    borderBottomWidth: 1,
+    width: 130,
+  },
+  lastMenuButton: {
+    marginVertical: 7,
+    paddingBottom: 5,
+    paddingHorizontal: 20,
+    zIndex: 999,
+    flexDirection: "row",
+    justifyContent: "space-between",
+    width: 130,
+  },
+  iconStyle: {
+    top: 2,
+  },
+  forwardIconStyle: {
+    top: 2,
+    left: 0,
+    transform: [
+      {rotateY: "180deg"}
+    ]
   }
 });
+
+
+const shareImage = async (viewRef) => {
+  try {
+    const uri = await captureRef(viewRef, {
+      format: "png",
+      quality: 0.8,
+    });
+
+    // share
+    const shareResponse = await Share.open({url: uri});
+  } catch (error) {
+    console.log("error", error);
+  }
+};
+
+
+
 const chatWallpaper = require("../images/chat_background.png");
 export default function ChatScreen({ navigation, route }) {
 
@@ -41,7 +134,9 @@ export default function ChatScreen({ navigation, route }) {
     return null;
   }
   const insets = useSafeArea();
+  const [selectedEvent, setSelectedEvent] = React.useState(false);
   const [showMenu, setShowMenu] = React.useState(false);
+  const [reply, setReply] = React.useState(false);
   const [lastpage, setLastPage] = React.useState(false);
   const ctx = React.useContext(ChatContext);
   const settings = ctx.getSettings();
@@ -49,6 +144,54 @@ export default function ChatScreen({ navigation, route }) {
   const parseEvents = React.useCallback((events)=> {
     return events;
   });
+
+  const MenuButton = ({event, text, Icon, iconName, size, style, viewRef, setSelectedEvent={setSelectedEvent}}) => {
+    return (
+      <TouchableOpacity onPress={()=>{
+        setTimeout(() => {
+          setSelectedEvent(false);
+        }, 100);
+        if (text === "Star") {
+          ctx.markMessage(event.id, "starred");
+        }
+        if (text === "Reply") {
+          setReply({text: event.text, event: event.id});
+        }
+        if (text === "Copy") {
+          Clipboard.setString(event.text);
+          Alert.alert("Message copied to clipboard");
+        }
+        if (text === "Forward") {
+          navigation.navigate('ContactsScreen', {event});
+        }
+        if (text === "Save") {
+          setTimeout(() => {
+            shareImage(viewRef);
+          },1);
+        }
+      }}>
+        <View style={style}>
+          <Text style={styles.menuText}>{text}</Text>
+          <Icon name={iconName} color={"white"} size={size} style={text==="Forward" ? styles.forwardIconStyle : styles.iconStyle} />
+        </View>
+      </TouchableOpacity>
+    );
+  }
+  const Menu = ({event, Icon, setSelectedEvent, viewRef, tapEvent}) => {
+    const username = ctx.getUserId();
+    const author = event?.owner?.id;
+    const isOwn = author === username;
+    return (
+      <View style={{...(isOwn ? styles.ownMenuBox : styles.menuBox), top: tapEvent.nativeEvent.pageY - 170}}>
+        <MenuButton style={styles.menuButton} event={event} text={"Star"} Icon={Icon} iconName={"star-icon"} size={15} setSelectedEvent={setSelectedEvent} />
+        <MenuButton style={styles.menuButton} event={event} text={"Reply"} Icon={Icon} iconName={"reply-icon"} size={12} setSelectedEvent={setSelectedEvent} />
+        <MenuButton style={styles.menuButton} event={event} text={"Forward"} Icon={Icon} iconName={"reply-icon"} size={12} setSelectedEvent={setSelectedEvent} />
+        <MenuButton style={styles.menuButton} event={event} text={"Copy"} Icon={Icon} iconName={"copy-icon"} size={15} setSelectedEvent={setSelectedEvent} />
+        <MenuButton viewRef={viewRef} style={styles.lastMenuButton} event={event} text={"Save"} Icon={Icon} iconName={"save-download-icon"} size={15} setSelectedEvent={setSelectedEvent} />
+      </View>
+    );
+  }
+
   React.useEffect(() => {
     const socket = getSocket();
 
@@ -58,15 +201,16 @@ export default function ChatScreen({ navigation, route }) {
         const parsedEvents = await parseEvents(decryptedEvents);
         ctx.setEvents({ conversationId: conversation.id, events: parsedEvents });
       });
-      socket.emit("events:mark_read", { conversationId: conversation.id, public: !!settings.disable_read_events }, function ({ success }) {
-        if (success) {
-          if (conversation.unreadCount) {
-            ctx.incrementUnreadCounts({ conversationId: conversation.id, count: -1 * conversation.unreadCount });
-          }
-          updateCount();
-        }
-      });
+      
     }
+    socket.emit("events:mark_read", { conversationId: conversation.id, public: !!settings.disable_read_events }, function ({ success }) {
+      if (success) {
+        if (conversation.unreadCount) {
+          ctx.incrementUnreadCounts({ conversationId: conversation.id, count: -1 * conversation.unreadCount });
+        }
+        updateCount();
+      }
+    });
 
     function handleUnread({ event }) {
       if (event && event.id && event.conversationId === conversation.id) {
@@ -103,13 +247,26 @@ export default function ChatScreen({ navigation, route }) {
       ctx.setEvents({ conversationId: conversation.id, events: events.concat(parsedEvents)});
     });
   }
+  const Icon = ctx.icon;
+  const buttons = <View style={styles.buttons}>
+    <Pressable style={styles.button} onPress={()=>{
+      navigation.navigate("VideoCalls",{callId:conversation.id, video:false});
+    }}>
+      <Icon name="medium-call-icon" style={styles.callIcon} />
+    </Pressable>
+    <Pressable style={styles.button} onPress={()=>{
+      navigation.navigate("VideoCalls",{callId:conversation.id, video:true});
+    }}>
+      <Icon name="medium-video-icon" style={styles.videoCallIcon} />
+    </Pressable>
+  </View>;
   let offset = 30 + insets.top;
   return (
     <>
-      <KeyboardAvoidingView  keyboardVerticalOffset={offset} style={styles.container} behavior={Platform.OS == "ios" ? "padding" : "height" }>
+      <View style={styles.container}>
         <Header
-          left={<PillButton text="Back" onPress={() => navigation.goBack()} />}
-          title={conversation.name || "Chat"} />
+          right={buttons}
+          title={ctx.getChatname(conversation)} />
         <View style={styles.inner}>
           <View style={styles.list}>
             <ImageBackground source={chatWallpaper} style={styles.wallpaper}>
@@ -117,7 +274,7 @@ export default function ChatScreen({ navigation, route }) {
                 if (events.length >= 20) {
                   fetchMoreMessages();
                 }
-              }} showMenu={showMenu} setShowMenu={setShowMenu}/>
+              }} setSelectedEvent={setSelectedEvent} />
               <TypingIndicator conversation={conversation} />
               <View style={styles.form}>
                 <ChatForm conversation={conversation} />
@@ -125,7 +282,8 @@ export default function ChatScreen({ navigation, route }) {
             </ImageBackground>
           </View>
         </View>
-      </KeyboardAvoidingView>
+        {selectedEvent && Menu({event: selectedEvent.event, Icon, setSelectedEvent, tapEvent: selectedEvent.tapEvent, viewRef: selectedEvent.viewRef})}
+      </View>
     </>
   );
 }
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js b/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
index 50d322e..0c38d64 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/MessageItem.js
@@ -6,10 +6,9 @@ import { ChatContext } from "../ChatContext";
 import { EventPropType } from "../PropTypes";
 import Colors from "../constants/Colors";
 
-import Clipboard from "@react-native-clipboard/clipboard";
-import {captureRef} from "react-native-view-shot";
-import Share from "react-native-share";
+
 import ReactNativeHapticFeedback from "react-native-haptic-feedback";
+import { ClientContext } from "../../../src/context/ClientContext";
 
 
 const chatSelf = require("../images/chat_gray.png");
@@ -20,7 +19,8 @@ const styles = StyleSheet.create({
   message: {
     borderRadius: 15,
     backgroundColor: "rgb(223,223,223)",
-    padding: 10,
+    padding: 15,
+    paddingHorizontal: 25,
     marginLeft: 25,
     marginRight: 80,
     marginVertical: 8,
@@ -32,9 +32,6 @@ const styles = StyleSheet.create({
     shadowOpacity: 0.1,
     shadowRadius: 6.27,
 
-    elevation: 10,
-    zIndex: 1,
-
   },
   selfMessage: {
     borderRadius: 25,
@@ -51,36 +48,53 @@ const styles = StyleSheet.create({
     },
     shadowOpacity: 0.15,
     shadowRadius: 6.27,
-    position: "relative",
-    elevation: 10,
-    zIndex: 1,
   },
   author: {
     fontWeight: "bold",
     color: Colors.AUTHOR,
     marginBottom: 4,
+    justifyContent: "center",
+  },
+  textBox: {
+    flexDirection: "row",
+  },
+  authorBox: {
+    flexDirection: "row",
   },
   body: {
     marginTop: 5,
   },
+  avatar: {
+    width:25,
+    height:25,
+    borderRadius: 20,
+    marginRight: 5,
+    top: -2,
+    justifyContent: "center",
+  },
   time: {
     textAlign: "right",
-    fontSize: 10,
+    fontSize: 9,
     fontWeight: "300",
     opacity: 0.4,
     color: "black",
+    left: 3,
+  },
+  timeBox: {
+    flexDirection: "row",
+    alignSelf: "flex-end",
+    left: 5,
+    top: 10,
   },
   readIndicator: {
-    position: "absolute",
-    bottom: 3,
-    right: 35,
-    fontSize: 10,
+    fontSize: 8,
+    left: 11,
+    top: 1,
   },
   deliveryIndicator: {
-    position: "absolute",
-    bottom: 3,
-    right: 25,
-    fontSize: 10,
+    fontSize: 8,
+    left: 10,
+    top: 1,
   },
   likeIndicatorBox: {
     position: "absolute",
@@ -128,123 +142,13 @@ const styles = StyleSheet.create({
     right : 10,
     top: 10,
     opacity: 0.2
-  },
-  menuBox: {
-    position: "absolute",
-    backgroundColor: "#333",
-    borderRadius: 20,
-    zIndex: 999,
-    bottom: 20,
-    right: -70,
-    paddingVertical: 5,
-  },
-  ownMenuBox: {
-    position: "absolute",
-    backgroundColor: "#333",
-    
-    borderRadius: 20,
-    zIndex: 999,
-    bottom: 20,
-    left: -70,
-    paddingVertical: 5,
-  },
-  menuText: {
-    color: "white",
-    fontSize: 12,
-  },
-  menuButton: {
-    marginVertical: 7,
-    paddingBottom: 15,
-    paddingHorizontal: 20,
-    zIndex: 999,
-    flexDirection: "row",
-    justifyContent: "space-between",
-    borderBottomColor: "white",
-    borderBottomWidth: 1,
-    width: 130,
-  },
-  lastMenuButton: {
-    marginVertical: 7,
-    paddingBottom: 5,
-    paddingHorizontal: 20,
-    zIndex: 999,
-    flexDirection: "row",
-    justifyContent: "space-between",
-    width: 130,
-  },
-  iconStyle: {
-    top: 2,
-  },
-  forwardIconStyle: {
-    top: 2,
-    left: 0,
-    //width: 20,
-    //height: 20,
-    transform: [
-      {rotateY: "180deg"}
-    ]
   }
 });
-async function shareImage (viewRef) {
-  try {
-    const uri = await captureRef(viewRef, {
-      format: "png",
-      quality: 0.8,
-    });
-
-    // share
-    const shareResponse = await Share.open({url: uri});
-  } catch (error) {
-    console.log("error", error);
-  }
-}
 
-function MenuButton({event, text, Icon, iconName, size, style, viewRef, setShowMenu={setShowMenu}}) {
-  return (
-    <TouchableOpacity onPress={()=>{
-      setShowMenu(false);
-      if (text === "Star") {
-        Alert.alert("Starred message");
-      }
-      if (text === "Reply") {
-        Clipboard.setString(event.text);
-      }
-      if (text === "Copy") {
-        Clipboard.setString(event.text);
-        Alert.alert("Message copied to clipboard");
-      }
-      if (text === "Forward") {
-        Clipboard.setString(event.text);
-        Alert.alert("Select contact");
-      }
-      if (text === "Save") {
-        setTimeout(() => {
-          shareImage(viewRef);
-        },100);
-      }
-    }}>
-      <View style={style}>
-        <Text style={styles.menuText}>{text}</Text>
-        <Icon name={iconName} color={"white"} size={size} style={text==="Forward" ? styles.forwardIconStyle : styles.iconStyle} />
-      </View>
-    </TouchableOpacity>
-  );
-}
-function Menu({event, isOwn, Icon, setShowMenu, viewRef}) {
-  return (
-    <View style={isOwn ? styles.ownMenuBox : styles.menuBox}>
-      <MenuButton style={styles.menuButton} event={event} text={"Star"} Icon={Icon} iconName={"star-icon"} size={15} setShowMenu={setShowMenu} />
-      <MenuButton style={styles.menuButton} event={event} text={"Reply"} Icon={Icon} iconName={"reply-icon"} size={12} setShowMenu={setShowMenu} />
-      <MenuButton style={styles.menuButton} event={event} text={"Forward"} Icon={Icon} iconName={"reply-icon"} size={12} setShowMenu={setShowMenu} />
-      <MenuButton style={styles.menuButton} event={event} text={"Copy"} Icon={Icon} iconName={"copy-icon"} size={15} setShowMenu={setShowMenu} />
-      <MenuButton viewRef={viewRef} style={styles.lastMenuButton} event={event} text={"Save"} Icon={Icon} iconName={"save-download-icon"} size={15} setShowMenu={setShowMenu} />
-    </View>
-  );
-}
-
-function Message({ event, text, time, author, isOwn, encrypted, menu, setShowMenu, Icon }) {
+function Message({ event, text, time, author, isOwn, encrypted, setSelectedEvent, Icon }) {
   const viewRef = React.useRef();
   const [likes, setLikes] = React.useState(0);
+  const ctx = React.useContext(ChatContext);
   const options = {
     enableVibrateFallback: true,
     ignoreAndroidSystemSettings: false
@@ -257,52 +161,71 @@ function Message({ event, text, time, author, isOwn, encrypted, menu, setShowMen
     setLikes(likes - 1);
     ReactNativeHapticFeedback.trigger("impactMedium", options);
   }
+  /*const likesButton = <TouchableOpacity style={styles.likeIndicatorBox} onPress={()=>sendLike(event)} onLongPress={()=>sendDislike(event)}>
+    <>
+      <Icon name={likes > 0 ? "heart" : "ei-heart"} color={"#f44"} style={likes > 0 ? styles.likeIndicator : styles.emptyLikeIndicator} />
+      {likes > 0 && <Text style={styles.likeText}>{likes}</Text>}
+    </>
+  </TouchableOpacity>;*/
+  const likesButton = null;
+
+  const users =  ctx.getUsers();
+  const getAvatar = React.useCallback((id) => {
+    const userId = users.findIndex(u => id == u.userId);
+    const userAvatar = users[userId].avatarUrl;
+    return userAvatar;
+  },[]);
+  const authorUrl = getAvatar(author);
   return (
-    <TouchableHighlight ref={viewRef} underlayColor={"#bbb"} style={isOwn ? styles.selfMessage : styles.message} delayLongPress={1000} onPress={(evt) => {
-      setShowMenu(false);
-    }} onLongPress={(evt) => {
-      setShowMenu(event.id);
-    }}>
-      <>
-        <Text style={styles.author}>{author}</Text>
-        <Text style={styles.body}>{text}</Text>
-        {encrypted ? <Image source={lockIcon} style={styles.encryptedIcon} /> : null }
-        <Text style={styles.time}>{(new Date(time)).toLocaleDateString()} {(new Date(time)).toLocaleTimeString()}</Text>
-        <Text style={styles.readIndicator}>
-          <Icon name="ticks" color={"rgb(228,140,58)"} />
-        </Text>
-        <Text style={styles.deliveryIndicator}>
-          <Icon name="ticks" color={"rgb(228,140,58)"} />
-        </Text>
-        <Pressable style={styles.likeIndicatorBox} onPress={()=>sendLike(event)} onLongPress={()=>sendDislike(event)}>
-          <>
-            <Icon name={likes > 0 ? "heart" : "ei-heart"} color={"#f44"} style={likes > 0 ? styles.likeIndicator : styles.emptyLikeIndicator} />
-            {likes > 0 && <Text style={styles.likeText}>{likes}</Text>}
-          </>
-        </Pressable>
-        {menu && Menu({event, isOwn, Icon, setShowMenu, viewRef})}
-      </>
-    </TouchableHighlight>
+    <>
+      <TouchableHighlight ref={viewRef} underlayColor={"#bbb"} style={isOwn ? styles.selfMessage : styles.message} delayLongPress={500} onPress={(evt) => {
+        setSelectedEvent(null);
+      }} onLongPress={(evt) => {
+        setSelectedEvent({event, viewRef, tapEvent:evt});
+      }}>
+        <>
+          <View style={styles.authorBox}>
+            <Image source={{url: authorUrl}} style={styles.avatar} />
+            <Text style={styles.author}>{ctx.getContactName(ctx.getUsernameByUserId(author))}</Text>
+          </View>
+          <View style={styles.textBox}>
+            
+            <Text style={styles.body}>{text}</Text>
+          </View>
+          {encrypted ? <Image source={lockIcon} style={styles.encryptedIcon} /> : null }
+          <View style={styles.timeBox}>
+            <Text style={styles.time}>{(new Date(time)).toLocaleDateString()} {(new Date(time)).toLocaleTimeString()}</Text>
+            <Text style={styles.readIndicator}>
+              <Icon name="ticks" color={!event.nonce || event.id != event.nonce ? (!event.readBy || !event.readBy.length || event.readBy.length > 1 ? "rgb(228,140,58)" : "rgb(90,213,90)") : "rgb(100,100,100)"} size={8} />
+            </Text>
+            <Text style={styles.deliveryIndicator}>
+              <Icon name="ticks" color={!event.nonce || event.id != event.nonce ? (!event.readBy || !event.readBy.length || event.readBy.length > 1 ? "rgb(228,140,58)" : "rgb(90,213,90)") : "rgb(100,100,100)"} size={8}/>
+            </Text>
+          </View>
+          {likesButton}
+        </>
+      </TouchableHighlight>
+    </>
   );
 }
 Message.propTypes = {
   text: PropTypes.string,
-  time: PropTypes.string,
+  time: PropTypes.any,
   author: PropTypes.string,
   isOwn: PropTypes.bool,
   encrypted: PropTypes.bool,
   setShowMenu: PropTypes.func,
 };
 
-export default function MessageItem ({ event, menu, setShowMenu }) {
+export default function MessageItem ({ event, menu, setSelectedEvent }) {
   const ctx = React.useContext(ChatContext);
-  const username = ctx.getUsername();
+  const username = ctx.getUserId();
   const isMessage = event?.type === "MESSAGE";
-  const author = event?.owner?.username;
+  const author = event?.owner?.id;
   const isOwn = author === username;
   if (isMessage) {
     if (event?.hidden) return null;
-    return (<Message Icon={ctx.icon} menu={menu} setShowMenu={setShowMenu} event={event} text={event?.text} isOwn={isOwn} author={author} time={event?.time} encrypted={event?.encrypted} />);
+    return (<Message Icon={ctx.icon} menu={menu} setSelectedEvent={setSelectedEvent} event={event} text={event?.text} isOwn={isOwn} author={author} time={event?.time} encrypted={event?.encrypted} />);
   } else {
     return (<Text style={styles.notification}>{event?.text}</Text>);
   }
diff --git a/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js b/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
index d7b227a..2fbc6d2 100644
--- a/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
+++ b/node_modules/react-native-chat-plugin/ChatScreen/MessagesList.js
@@ -1,29 +1,98 @@
 import React from "react";
-import { FlatList } from "react-native";
+import { FlatList, View, TouchableOpacity, Text } from "react-native";
 import PropTypes from "prop-types";
 
 import MessageItem from "./MessageItem";
 import { EventPropType } from "../PropTypes";
+import {StyleSheet} from 'react-native';
 
-
-function renderItem({ item, showMenu, setShowMenu }) {
-  return (<MessageItem event={item} menu={item.id == showMenu} setShowMenu={setShowMenu} />);
+function renderItem({ item, setSelectedEvent }) {
+  return (<MessageItem event={item} setSelectedEvent={setSelectedEvent} />);
 }
 renderItem.propTypes = {
   item: EventPropType,
 };
 
-export default function MessageList({ events, onEndReached, showMenu, setShowMenu }) {
+const renderCell = ({index, style, ...props}) => {
+  zIndex = index;
+  return <View style={[style, zIndex]} {...props} />;
+}
+
+
+
+export default function MessageList({ events, onEndReached, setSelectedEvent }) {
+  const flatlistRef = React.useRef();
+  const [goToBottom, setGoToBottom] = React.useState(false);
+  const scrollToEnd = React.useCallback(() => {
+    flatlistRef.current.scrollToIndex({index:0});
+  }, [flatlistRef])
+  const ctx = React.useContext(ChatContext);
+  const Icon = ctx.icon;
   return (
-    <FlatList
-      inverted={true}
-      data={[...events].reverse()}
-      renderItem={({item}) => renderItem({item, showMenu, setShowMenu})}
-      onEndReached={onEndReached}
-      onEndReachedThreshold={0.5}
-    />
+    <>
+      <FlatList
+        ref={flatlistRef}
+        scrollEventThrottle={200}
+        onScroll={(event) => {
+          const scrollOffset = event.nativeEvent.contentOffset.y
+          if (scrollOffset > 0 && !goToBottom) {
+            setGoToBottom(true);
+          } else if (goToBottom && scrollOffset <= 0) {
+            setGoToBottom(false);
+          }
+        }}
+        contentContainerStyle={{ paddingBottom: 20 }}
+        inverted
+        data={[...events].reverse()}
+        renderItem={({item}) => renderItem({item, setSelectedEvent})}
+        onEndReached={onEndReached}
+        onEndReachedThreshold={0.5}
+        removeClippedSubviews={false}
+      />
+      {goToBottom && <TouchableOpacity style={styles.goToBottom} onPress={scrollToEnd}>
+          <View style={styles.goToBottomIconContainer}>
+            <Icon name={"arrow"} style={styles.goToBottomIcon}/>
+          </View>
+        </TouchableOpacity>}
+    </>
   );
 }
+
+
+
+import {
+  responsiveHeight,
+  responsiveWidth,
+  responsiveFontSize
+} from 'react-native-responsive-dimensions';
+import { ChatContext } from "react-native-chat-plugin/ChatContext";
+const styles = StyleSheet.create({
+  goToBottom: {
+      position: "absolute",
+      right: 0,
+      backgroundColor: "rgb(124, 178, 128)",
+      bottom: responsiveWidth(30),
+      borderTopLeftRadius: responsiveWidth(5),
+      borderBottomLeftRadius: responsiveWidth(5),
+      paddingVertical: responsiveWidth(2),
+      paddingHorizontal: responsiveWidth(3),
+  },
+  goToBottomIcon: {
+    fontSize: responsiveFontSize(1.2),
+    color: "white",
+    top: 1,
+  },
+  goToBottomIconContainer: {
+    borderWidth: 1,
+    borderRadius: 40,
+    borderColor: "white",
+    padding: responsiveWidth(2),
+    justifyContent: "center",
+    width: 30,
+    height: 30,
+  }
+});
+
 MessageList.propTypes = {
   events: PropTypes.arrayOf(EventPropType),
   onEndReached: PropTypes.func
diff --git a/node_modules/react-native-chat-plugin/Components/PillButton.js b/node_modules/react-native-chat-plugin/Components/PillButton.js
index 42efb16..f2714f7 100644
--- a/node_modules/react-native-chat-plugin/Components/PillButton.js
+++ b/node_modules/react-native-chat-plugin/Components/PillButton.js
@@ -13,6 +13,7 @@ const styles = StyleSheet.create({
     margin: 1,
     paddingVertical: 10,
     paddingHorizontal: 8,
+    right: 5,
   },
   buttonText: {
     color: Colors.BACKGROUND,
diff --git a/node_modules/react-native-chat-plugin/Components/TextInput.js b/node_modules/react-native-chat-plugin/Components/TextInput.js
index 64f1ea6..3658991 100644
--- a/node_modules/react-native-chat-plugin/Components/TextInput.js
+++ b/node_modules/react-native-chat-plugin/Components/TextInput.js
@@ -1,8 +1,21 @@
 import React from "react";
 import PropTypes from "prop-types";
 import { TextInput as RNTextInput, View, StyleSheet, Image } from "react-native";
+import { responsiveWidth } from "react-native-responsive-dimensions";
 const searchIcon = require("../images/search_icon.png");
 const styles = StyleSheet.create({
+  textContainer: {
+    margin: 10,
+    marginHorizontal: 22,
+    backgroundColor: "rgb(235,235,235)",
+    padding: 10,
+    borderRadius: 6,
+    paddingLeft: 10,
+    borderWidth:1,
+    borderColor: "#c2c2c2",
+    width: responsiveWidth(63),
+    top: 10,
+  },
   searchContainer: {
     margin: 10,
     marginHorizontal: 22,
@@ -30,12 +43,12 @@ const styles = StyleSheet.create({
   }
 });
 
-export default function TextInput({ onChangeText, defaultValue, placeholder }) {
+export default function TextInput({ onChangeText, defaultValue, placeholder, hideIcon }) {
   const [query, setQuery] = React.useState(defaultValue);
   return (
     <View style={styles.searchParent}>
-      <View style={styles.searchContainer}>
-        <Image source={searchIcon} style={styles.searchIcon} />
+      <View style={!hideIcon ? styles.searchContainer : styles.textContainer}>
+        {!hideIcon && <Image source={searchIcon} style={styles.searchIcon} /> }
         <RNTextInput
           style={styles.searchText}
           blurOnSubmit={true}
diff --git a/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js b/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
index a3184cd..b524565 100644
--- a/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
+++ b/node_modules/react-native-chat-plugin/ContactsScreen/ContactComponent.js
@@ -7,6 +7,7 @@ import Fonts from "../constants/Fonts";
 import { ConversationPropType } from "../PropTypes";
 import { ChatContext } from "../ChatContext";
 import LinearGradient from "react-native-linear-gradient";
+import { responsiveFontSize } from "react-native-responsive-dimensions";
 const styles = StyleSheet.create(
   {
     container: {
@@ -58,12 +59,18 @@ const styles = StyleSheet.create(
       color: Colors.TEXT,
     },
     encryptedIcon: {
-      position: "absolute",
-      width: 10,
-      height: 10,
-      right : 1,
-      top: 3,
-      opacity: 0.6
+    },
+    mutedIcon: {
+      width: 20,
+    },
+    conversationName: {
+      flexDirection: "row",
+    },
+    conversationIcon: {
+      top: 7,
+      marginLeft: 5,
+      fontSize: responsiveFontSize(1.3),
+      color: "rgb(150,150,150)"
     }
   }
 );
@@ -84,20 +91,29 @@ export default function ContactComponent({ conversation, onPress }) {
   const unreadCount = conversation.unreadCount ? parseInt(conversation.unreadCount) : 0;
   const ctx = useContext(ChatContext);
   const user = ctx.getUser();
+  const users = ctx.getUsers();
   let participants = conversation.participants;
   if (user && Array.isArray(participants) && participants.length > 1) {
     participants = participants.filter(p => p.id !== user.id);
   }
-
+  const Icon = ctx.icon;
+  const chatName = ctx.getChatname(conversation);
   return (
     <TouchableHighlight
       onPress={() => (onPress && onPress(conversation))}
       underlayColor="#F8E2DD">
       <LinearGradient style={styles.container} colors={['#ffffff', '#f3f3f3']}>
-        <ProfilePreview text={conversation.name} contacts={participants} />
-        {conversation.encrypted ? <Image source={lockIcon} style={styles.encryptedIcon} /> : null }
+        <Text></Text>
+        <ProfilePreview text={chatName} contacts={participants} />
+        
         <View>
-          <Text style={styles.name}>{conversation.name}</Text>
+          <View style={styles.conversationName}>
+            <Text style={styles.name}>{chatName}</Text>
+            {conversation.encrypted ? <Image source={lockIcon} style={styles.conversationIcon} /> : null }
+            {conversation.muted && <Icon name="mute-icon" style={styles.conversationIcon} />}
+            {conversation.pinned && <Icon name="office-push-pin" style={styles.conversationIcon} />}
+            {conversation.archived && <Icon name="archive" style={styles.conversationIcon} />}
+          </View>
           <Text style={styles.preview}>{ getPreview(conversation) }</Text>
         </View>
         {getPreviewDate(conversation)}
diff --git a/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js b/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
index fa4d21e..b1e5d22 100644
--- a/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/ContactsScreen/ContactsScreen.js
@@ -16,6 +16,7 @@ const closeIcon = require("../images/close.png");
 const styles = StyleSheet.create({
   container: {
     flex: 1,
+    zIndex: 1,
   },
   buttonsContainer: {
     flexDirection: "row",
@@ -27,11 +28,17 @@ const styles = StyleSheet.create({
     flex: 1,
     flexDirection: "column",
   },
+  leftSwipeContainer: {
+    alignSelf: "flex-start",
+    flexDirection: "row",
+    width: 120,
+    zIndex: 10,
+    top: 5
+  }, 
   deleteContainer: {
-    flex: 1,
     alignSelf: "flex-end",
     flexDirection: "row",
-    width: 120,
+    width: 180,
     zIndex: 10,
     top: 5
   },
@@ -48,23 +55,44 @@ const styles = StyleSheet.create({
     flexDirection: "column",
     justifyContent: "center",
     backgroundColor: "rgb(130,180,120)"
-    
+  },
+  pinView: {
+    width: 60,
+    height: "100%",
+    alignItems: "center",
+    flexDirection: "column",
+    justifyContent: "center",
+    backgroundColor: "rgb(77,146,163)"
+  },
+  unreadView: {
+    width: 60,
+    height: "100%",
+    alignItems: "center",
+    flexDirection: "column",
+    justifyContent: "center",
+    backgroundColor: "rgb(111,111,111)"
   },
   muteText: {
-    width:25,
-    height: 25,
     color: "white",
-    fontSize: 25,
+    fontSize: 22,
   },
   muteTextText: {
     color: "white",
     fontSize: 11,
-    marginTop: 5,
+    marginTop: 10,
   },
   deleteTextText: {
     color: "white",
     fontSize: 11,
-    marginTop: 5,
+    marginTop: 10,
+  },
+  archiveView: {
+    width: 60,
+    height: "100%",
+    alignItems: "center",
+    flexDirection: "column",
+    justifyContent: "center",
+    backgroundColor: "rgb(111,111,111)"
   },
   deleteView: {
     width: 60,
@@ -72,14 +100,15 @@ const styles = StyleSheet.create({
     alignItems: "center",
     flexDirection: "column",
     justifyContent: "center",
-    backgroundColor: "rgb(227,140,58)"
-    
+    backgroundColor: "rgb(201, 66, 59)"
   },
   deleteText: {
-    width:25,
-    height: 25,
     color: "white",
-    fontSize: 25,
+    fontSize: 22,
+  },
+  archiveText: {
+    color: "white",
+    fontSize: 22,
   },
   chatBackground: {
     flex: 1,
@@ -101,45 +130,27 @@ const styles = StyleSheet.create({
     backgroundColor: "rgb(145,145,145)",
     borderRadius: 30,
     height: 400,
+  },
+  hiddenItemContainer: {
+    flexDirection: "row",
+    justifyContent: "space-between",
   }
 });
 const chatWallpaper = require("../images/chat_background.png");
-const renderConversation = (conversation, onPress) => {
-  return (
-    <ContactComponent conversation={conversation} onPress={onPress} />
-  );
-};
-
-const renderHiddenItem = (item, ctx) => {
-  const Icon = ctx.icon;
-  return (
-    <View style={styles.deleteContainer}>
-      <TouchableOpacity style={styles.deleteViewParent} onPress={() => ctx.deleteConversation(item.id, false)}>
-        <View style={styles.muteView}>
-          <Icon name="mute-icon"  style={styles.muteText} />
-          <Text style={styles.muteTextText}>Mute</Text>
-        </View>
-      </TouchableOpacity>
-      <TouchableOpacity style={styles.deleteViewParent} onPress={() => ctx.muteConversation(item.id, false)}>
-        <View style={styles.deleteView}>
-          <Icon name="trash"  style={styles.deleteText} />
-          <Text style={styles.deleteTextText}>Delete</Text>
-        </View>
-      </TouchableOpacity>
-    </View>
-  );
-};
 
-export default function ConversationList({ navigation }) {
+export default function ContactsScreen({ navigation, route }) {
   const ctx = React.useContext(ChatContext);
-  const conversations = ctx.getConversations().filter(c => c.hidden == undefined || !c.hidden);
+  const swiper = React.useRef();
+  const filter = route.params?.filter;
+  const conversations = filter == 'groups' ? [] : ctx.getConversations()
+  .filter(c => c.hidden == undefined || !c.hidden)
+  .filter(c => route.params?.type == 'archived' ? c.archived : !c.archived)
+  //.filter(c => route.params.type == 'pinned' && !c.pinned)
   const [results, setResults] = React.useState([]);
   const onPress = (conversation) => {
     navigation.navigate("ChatScreen", { conversation });
   };
-
   const [query, setQuery] = React.useState("");
-
   function searchAsyncForMessages(ctx, query) {
     searchForMessages(ctx, query).then((resultsFromDB) => {
       if (JSON.stringify(resultsFromDB) != JSON.stringify(results)) {
@@ -177,37 +188,111 @@ export default function ConversationList({ navigation }) {
       return convMatches;
     }
   }, [query, conversations, results]);
-  const buttons = <>
-    <PillButton text="Add contacts" onPress={() => navigation.navigate("PhoneContactsScreen")} />
-    <PillButton text="New Public Channel" onPress={() => navigation.navigate("SearchContactsScreen")} />
-    <PillButton text="New 1 to 1 Chat" onPress={() => navigation.navigate("SearchContactsScreen")} />
-  </>
+
+  const keyExtractor = item => item.id;
+
+  const renderConversation = ({item}) => {
+    return (
+      <ContactComponent conversation={item} onPress={onPress} />
+    );
+  };
+  const markConversation = React.useCallback((conversation, type, value) => {
+    switch (type) {
+      case 'pin':
+        ctx.pinConversation(conversation.id, !conversation.pinned);
+        break;
+      case 'mute':
+        ctx.muteConversation(conversation.id, !conversation.muted);
+        break;
+      case 'delete':
+        ctx.deleteConversation(conversation.id, false);
+        break;
+      case 'archive':
+        ctx.archiveConversation(conversation.id, !conversation.archived);
+        break;
+      case 'unread':
+        ctx.unreadConversation(conversation.id, !conversation.unread);
+        break;
+      default:
+        break;
+    }
+    if (type != 'unread') {
+      ctx.markConversation(conversation.id, type, value);
+    }
+    swiper.current?.closeAllOpenRows();
+  },[]);
+  const renderHiddenItem = ({item}) => {
+    const Icon = ctx.icon;
+    return (
+      <View style={styles.hiddenItemContainer}>
+        <View style={styles.leftSwipeContainer}>
+          <TouchableOpacity style={styles.deleteViewParent} onPress={() => markConversation(item, 'unread')}>
+            <View style={styles.unreadView}>
+              <Icon name="unread"  style={styles.muteText} />
+              <Text style={styles.muteTextText}>Unread</Text>
+            </View>
+          </TouchableOpacity>
+          <TouchableOpacity style={styles.deleteViewParent} onPress={() => markConversation(item, 'pin')}>
+            <View style={styles.pinView}>
+              <Icon name="office-push-pin"  style={styles.deleteText} />
+              <Text style={styles.deleteTextText}>{item.pinned ? "Unpin" : "Pin"}</Text>
+            </View>
+          </TouchableOpacity>
+        </View>
+  
+        <View style={styles.deleteContainer}>
+          <TouchableOpacity style={styles.deleteViewParent} onPress={() => markConversation(item, 'mute')}>
+            <View style={styles.muteView}>
+              <Icon name="mute-icon"  style={styles.muteText} />
+              <Text style={styles.muteTextText}>{item.muted ? "Unmute" : "Mute"}</Text>
+            </View>
+          </TouchableOpacity>
+          <TouchableOpacity style={styles.deleteViewParent} onPress={() => markConversation(item, 'delete')}>
+            <View style={styles.deleteView}>
+              <Icon name="trash"  style={styles.deleteText} />
+              <Text style={styles.deleteTextText}>Delete</Text>
+            </View>
+          </TouchableOpacity>
+          <TouchableOpacity style={styles.deleteViewParent} onPress={() => markConversation(item, 'archive')}>
+            <View style={styles.archiveView}>
+              <Icon name="archive"  style={styles.archiveText} />
+              <Text style={styles.deleteTextText}>{item.archived ? "Unarchive" : "Archive"}</Text>
+            </View>
+          </TouchableOpacity>
+        </View>
+      </View>
+    );
+  };
+
+  
   return (
     <View style={styles.container}>
       <Header />
       <TextInput placeholder={"Search"} onChangeText={query => setQuery(query)} />
       <ImageBackground source={chatWallpaper} style={styles.chatBackground}>
-        <View style={styles.buttonsContainer}>
-          {buttons}
-        </View>
         <SwipeListView
           style={styles.container}
           swipeRowStyle={styles.rowStyle}
           data={displayConversations || conversations || []}
-          renderItem={({item}) => renderConversation(item, onPress)}
-          renderHiddenItem={({item}) => renderHiddenItem(item, ctx)}
+          renderItem={renderConversation}
+          renderHiddenItem={renderHiddenItem}
           disableLeftSwipe={false}
-          disableRightSwipe={true}
+          disableRightSwipe={false}
           recalculateHiddenLayout={false}
-          rightOpenValue={-120}
+          rightOpenValue={-180}
+          stopLeftSwipe={120}
+          stopRightSwipe={-180}
+          leftOpenValue={120}
           closeOnRowBeginSwipe={true}
-          keyExtractor={item => item.id}
+          keyExtractor={keyExtractor}
+          useNativeDriver
+          ref={swiper}
         />
       </ImageBackground>
     </View>
   );
 }
 
-ConversationList.propTypes = {
+ContactsScreen.propTypes = {
   navigation: NavigationPropType,
 };
\ No newline at end of file
diff --git a/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js b/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
index 731a30e..7cbfc76 100644
--- a/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/PhoneContactsScreen/PhoneContactsScreen.js
@@ -6,6 +6,15 @@ import { ChatContext } from "../ChatContext";
 import { NavigationPropType } from "../PropTypes";
 import LinearGradient from "react-native-linear-gradient";
 import { TouchableHighlight } from "react-native-gesture-handler";
+
+import SendSMS from 'react-native-sms'
+import { responsiveFontSize } from "react-native-responsive-dimensions";
+import APIService from "../../../src/service/APIService";
+import {ClientContext} from '../../../src/context/ClientContext';
+import { clearPhoneNumber } from "../../../src/utils/phonehelpers";
+import trans from "../../../src/utils/trans";
+
+
 const styles = StyleSheet.create({
   container: {
     flex: 1,
@@ -100,9 +109,18 @@ const styles = StyleSheet.create({
     width: 20,
     height: 20,
     borderRadius: 20,
-    borderWidth: 1,
+    borderWidth: 0.5,
     borderColor: "#333",
   },
+  markedContactToggle: {
+    backgroundColor: "rgb(75,159,183)",
+    width: 20,
+    height: 20,
+    borderRadius: 20,
+    borderWidth: 1,
+    borderColor: "rgb(75,159,183)",
+    justifyContent: "center",
+  },
   headerStyle: {
     backgroundColor: "rgb(125,125,125)",
     padding: 20,
@@ -111,65 +129,153 @@ const styles = StyleSheet.create({
   },
   headerButtonStyle: {
     color: "white",
+  },
+  markTick: {
+    color: "white",
+    fontSize: responsiveFontSize(1.2),
+    justifyContent: "center",
+    alignSelf: "center",
+  },
+  alreadyExists: {
+    fontSize: responsiveFontSize(1.1),
+    alignSelf: "center",
+    position: "absolute",
+    left: 20,
+    bottom: 10,
+  },
+  numberOfFriends: {
+    fontSize: responsiveFontSize(1.1),
+    alignSelf: "center",
+    position: "absolute",
+    left: 20,
+    bottom: 10,
   }
 });
 
-const Contact = ({ctx, item}) => {
-  const [marked, setMarked] = React.useState(false);
-  const Icon = ctx.icon;
   
-  return (
-    <TouchableOpacity >
-      <LinearGradient style={styles.listItemContainer} colors={['#fff','#f3f3f3']}>
-        <Text style={styles.listItemLabel}>{item.value}</Text>
-        <View style={styles.contactToggle}>
-
-        </View>
-      </LinearGradient>
-    </TouchableOpacity>
-  );
-};
+const onShare = async (numbers, navigation) => {
+  SendSMS.send({
+    body: 'Hey - Join Wevive, a social network for doing good. Here is the link - https://wevive.com',
+    recipients: numbers,
+    successTypes: ['sent', 'queued'],
+    allowAndroidSendWithoutReadPermission: true,
+  }, (completed, cancelled, error) => {
+    if (completed) {
+      navigation.navigate('SearchContactsScreen');
+    }
+    //console.warn('SMS Callback: completed: ' + completed + ' cancelled: ' + cancelled + 'error: ' + error);
+  });
+}
 
-const renderSectionHeader = (ctx, section) => {
-  const Icon = ctx.icon;
+
+const renderSectionHeader = (section) => {
   return (
     <View style={styles.sectionHeaderContainer}>
       <Text style={styles.sectionHeaderLabel}>{section.title}</Text>
-      
     </View>
   );
 };
 
-export default function ConversationList({ navigation }) {
+export default function PhoneContactsScreen({ navigation }) {
   const ctx = React.useContext(ChatContext);
+  const clientctx = React.useContext(ClientContext);
+  const Icon = ctx.icon;
+  const [selectedContacts, setSelectedContacts] = React.useState([]);
+  const [existingUsers, setExistingUsers] = React.useState({existing:[],contacts:[],friendCounts: []});
   const contacts = ctx.contacts;
+  
+  const getNumbers = () => {
+    const numbers = [];
+    
+    ctx.contacts.forEach(c => {
+      if (!c.labels) {
+        numbers.push(clearPhoneNumber(clientctx.geo.geo.country_code, c.label))
+      } else {
+        c.labels.forEach(l => {
+          numbers.push(clearPhoneNumber(clientctx.geo.geo.country_code, l))
+        })
+      }
+    });
+    return numbers;
+  };
+  React.useEffect(() => {
+    const friends = [];
+    const friendCounts = [];
+    APIService('phone-contacts/sync/',{numbers: getNumbers()}).then((r)=>{
+      r.contacts.forEach(u => {
+        friends.push(u.phone_number);
+        friendCounts.push(u.users);
+      });
+      setExistingUsers(
+        {
+          existing: r.users.map(u => u.phone_number),
+          contacts: friends,
+          friendCounts: friendCounts,
+        }
+      );
+    });
+  },[]);
+  const toggleSelected = (item, marked) => {
+    if (marked < 0) {
+      setSelectedContacts(selectedContacts.concat([item.label]));
+    } else {
+      setSelectedContacts(selectedContacts.filter((r)=>(r != item.label)));
+    }
+  };
+  const Contact = ({item, marked}) => {
+    const cleanedNumber = clearPhoneNumber(clientctx.geo.geo.country_code, item.label);
+    const alreadyExists = existingUsers.existing.indexOf(cleanedNumber) !== -1;
+    const numberOfFriends = existingUsers.contacts && existingUsers.contacts.indexOf(cleanedNumber) !== -1 ? existingUsers.friendCounts[existingUsers.contacts.indexOf(cleanedNumber)] - 1 : 0;
+    return (
+      <TouchableOpacity onPress={()=>!alreadyExists && toggleSelected(item, marked)}>
+        <LinearGradient style={styles.listItemContainer} colors={['#fff','#f3f3f3']}>
+          <Text style={styles.listItemLabel}>{item.value}</Text>
+          {alreadyExists && <Text style={styles.alreadyExists}>Wevive user</Text>}
+          {!alreadyExists && numberOfFriends > 0 && <Text style={styles.numberOfFriends}>{trans('chats.friend_of_',{count:numberOfFriends})}</Text>}
+          {!alreadyExists && <View style={selectedContacts.indexOf(item.label) >= 0 ? styles.markedContactToggle : styles.contactToggle}>
+            {selectedContacts.indexOf(item.label) >= 0 && <Icon name="ticks" style={styles.markTick}/>}
+          </View>}
+        </LinearGradient>
+      </TouchableOpacity>
+    );
+  };
+
+  
+  
   const goBack = () => {
     navigation.goBack();
   };
-  //console.error(contacts.length);
-  return (
-    <View style={styles.container}>
+  const goNext = () => {
+    onShare(selectedContacts, navigation);
+  }
+  const renderItem = (item) => <Contact key={item.value} item={item} marked={selectedContacts.indexOf(item.label)} />;
+  return contacts && (
+    <>
       <View style={styles.headerStyle}>
         <TouchableOpacity onPress={goBack}>
           <Text style={styles.headerButtonStyle}>Cancel</Text>
         </TouchableOpacity>
-        <TouchableOpacity onPress={goBack}>
+        {selectedContacts.length > 0 && <TouchableOpacity onPress={goNext}>
           <Text style={styles.headerButtonStyle}>Next</Text>
-        </TouchableOpacity>
+        </TouchableOpacity>}
       </View>
-      <AlphabetList
-        data={contacts}
-        indexLetterColor={'white'}
-        indexLetterSize={15}
-        alphabetContainer={styles.alphabetContainer}
-        renderItem={(item) => <Contact item={item} ctx={ctx} />}
-        renderSectionHeader={(section) => renderSectionHeader(ctx, section)}
-        letterItemStyle={styles.letterItemStyle}
-      />
-    </View>
+      <View style={styles.container}>
+        <AlphabetList
+          data={contacts}
+          indexLetterColor={'white'}
+          indexLetterSize={15}
+          alphabetContainer={styles.alphabetContainer}
+          renderItem={renderItem}
+          renderSectionHeader={renderSectionHeader}
+          letterItemStyle={styles.letterItemStyle}
+        />
+      </View>
+    </>
   );
 }
 
-ConversationList.propTypes = {
+//PhoneContactsScreen.whyDidYouRender = true;
+
+PhoneContactsScreen.propTypes = {
   navigation: NavigationPropType,
 };
\ No newline at end of file
diff --git a/node_modules/react-native-chat-plugin/PropTypes.js b/node_modules/react-native-chat-plugin/PropTypes.js
index c76b0d1..a5e3b06 100644
--- a/node_modules/react-native-chat-plugin/PropTypes.js
+++ b/node_modules/react-native-chat-plugin/PropTypes.js
@@ -17,7 +17,7 @@ export const EventPropType = PropType.shape({
   type: PropType.string,
   text: PropType.string,
   owner: UserPropType,
-  time: PropType.string,
+  time: PropType.any,
   conversationId: PropType.string,
 });
 
@@ -28,3 +28,11 @@ export const ConversationPropType = PropType.shape({
   participants: PropType.arrayOf(UserPropType),
   typing: PropType.arrayOf(PropType.string),
 });
+
+export const CallProptype = PropType.shape({
+  id: PropType.number,
+  name: PropType.string,
+  duration: PropType.number,
+  created_at: PropType.number,
+  author: PropType.string,
+});
diff --git a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
index b708a42..db0080f 100644
--- a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
+++ b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchContactsScreen.js
@@ -1,5 +1,5 @@
 import React from "react";
-import { FlatList, View, StyleSheet, ActivityIndicator, Alert } from "react-native";
+import { FlatList, View, StyleSheet, Image, ActivityIndicator, Alert, Text, TouchableOpacity } from "react-native";
 
 import { NavigationPropType } from "../PropTypes";
 import PillButton from "../Components/PillButton";
@@ -9,7 +9,7 @@ import SearchResultComponent from "./SearchResultComponent";
 import { getSocket } from "../utils/SocketIOClient";
 import { ChatContext } from "../ChatContext";
 import { initEncryption } from "../utils/ChatEncryption";
-
+import AlphabetList from "react-native-flatlist-alphabet";
 import {
   SearchReducer,
   SearchInitialState,
@@ -18,6 +18,14 @@ import {
   dispatchAppendContactsAction,
   dispatchEndReachedAction
 } from "./SearchReducers";
+import { useRoute } from "@react-navigation/native";
+import { clearPhoneNumber } from "../../../src/utils/phonehelpers";
+import {ClientContext} from '../../../src/context/ClientContext';
+
+import ImagePicker from 'react-native-image-crop-picker';
+import { responsiveWidth } from "react-native-responsive-dimensions";
+import APIService from "../../../src/service/APIService";
+
 
 const styles = StyleSheet.create({
   container: {
@@ -27,19 +35,101 @@ const styles = StyleSheet.create({
     flex: 1,
     justifyContent: "center",
   },
+  headerStyle: {
+    backgroundColor: "rgb(125,125,125)",
+    padding: 20,
+    flexDirection: "row",
+    justifyContent: "space-between",
+  },
+  listItemContainer: {
+    padding: 20,
+    flexDirection: "row",
+    justifyContent: "space-between",
+    paddingRight: 50,
+  },
+  sectionHeaderContainer: {
+    backgroundColor: "rgb(125,125,125)",
+    paddingVertical: 7,
+    paddingHorizontal: 20,
+    
+  },
+  sectionHeaderLabel: {
+    fontWeight: "700",
+    color: "white",
+  },
+  alphabetContainer: {
+    backgroundColor: "rgb(145,145,145)",
+    borderRadius: 30,
+    alignSelf: "center",
+    flex: 1,
+    left: 50,
+    
+  },
+  letterItemStyle: {
+    //padding: 10,
+    height: 20,
+    width: 30,
+  },
+  avatarContainer: {
+    alignSelf: "center",
+    justifyContent: "center",
+  },
+  profileImage: {
+    width: responsiveWidth(20),
+    height: responsiveWidth(20),
+    borderRadius: responsiveWidth(10),
+    marginLeft: responsiveWidth(5),
+    marginVertical: responsiveWidth(1),
+    backgroundColor: "rgb(227,165,57)",
+    justifyContent: "center",
+    alignSelf: "center",
+  },
+  profilePlaceholder: {
+    color: "white",
+    justifyContent: "center",
+    textAlign: "center",
+    alignSelf: "center",
+  },
+  groupRow: {
+    flexDirection: "row",
+  }
 });
 
-const renderContact = (contact, onPress) => {
-  return <SearchResultComponent contact={contact} onPress={onPress} />;
+
+const renderSectionHeader = (ctx, section) => {
+  const Icon = ctx.icon;
+  return (
+    <View style={styles.sectionHeaderContainer}>
+      <Text style={styles.sectionHeaderLabel}>{section.title}</Text>
+      
+    </View>
+  );
 };
 
-export default function SearchContactsScreen({ navigation }) {
+export default function SearchContactsScreen({navigation, route}) {
   const [query, setQuery] = React.useState("");
   const [loading, setLoading] = React.useState(false);
+  const [conversationName, setConversationName] = React.useState("");
   const [state, dispatch] = React.useReducer(SearchReducer, SearchInitialState);
   const ctx = React.useContext(ChatContext);
   const socket = getSocket();
-
+  const [conversationAvatar, setConversationAvatar] = React.useState({
+    avatarImage: "",
+    default: true,
+  });
+  const Icon = ctx.icon;
+  const createGroup = async(name) => {
+    return APIService('group', {
+      photo: conversationAvatar.avatarImage,
+      filename: conversationAvatar.avatarFile,
+      mime: conversationAvatar.avatarMime,
+      name: name,
+    }).then((result) => {
+      if (result) {
+        return result;
+      }
+    });
+  };
   const update = (success, contacts, dispatcher) => {
     if (!success || (contacts && contacts.length === 0)) {
       dispatcher(dispatch, contacts);
@@ -49,13 +139,25 @@ export default function SearchContactsScreen({ navigation }) {
     }
   };
 
+  const clientctx = React.useContext(ClientContext);
+  const contacts = ctx.contacts;
+  const [friends, setFriends] = React.useState([]);
+  React.useEffect(() =>{
+    const ffriends = {};
+    contacts.forEach(c => {
+      const cleanedNumber = clearPhoneNumber(clientctx.geo.geo.country_code, c.label);
+      ffriends[cleanedNumber] = c.value;
+    });
+    setFriends(ffriends);
+  },[]);
+
   const getUsers = () => {
     if (!query) {
-      socket.emit("users:get_followings", { page: 1 }, function ({ success, followings }) {
+      socket.emit("users:get_followings", { type: route.params.type, page: 1 }, function ({ success, followings }) {
         update(success, followings, dispatchUpdateContactsAction);
       });
     } else {
-      socket.emit("users:get_followings", { page: 1 }, ({ success, followings }) => {
+      socket.emit("users:get_followings", { type: route.params.type, page: 1 }, ({ success, followings }) => {
         if (followings) {
           followings = followings.filter((follower) => {
             return follower.username.toLowerCase().indexOf(query.toLowerCase()) >= 0;
@@ -69,11 +171,11 @@ export default function SearchContactsScreen({ navigation }) {
   const getMoreUsers = () => {
     if (state.page > 0) {
       if (!query) {
-        socket.emit("users:get_followings", { page: state.page + 1 }, function ({ success, followings }) {
+        socket.emit("users:get_followings", { type: route.params.type, page: state.page + 1 }, function ({ success, followings }) {
           update(success, followings, dispatchAppendContactsAction);
         });
       } else {
-        socket.emit("users:get_followings", { page: state.page + 1 }, ({ success, followings }) => {
+        socket.emit("users:get_followings", { type: route.params.type, page: state.page + 1 }, ({ success, followings }) => {
           if (followings) {
             followings = followings.filter((follower) => {
               return follower.username.toLowerCase().indexOf(query.toLowerCase()) >= 0;
@@ -88,32 +190,59 @@ export default function SearchContactsScreen({ navigation }) {
   React.useEffect(() => {
     const timer = setTimeout(() => {
       getUsers();
-    }, 300);
+    }, 100);
 
     return () => clearTimeout(timer);
   }, [query]);
-
+  const getSocketAction = () => {
+    return "conversations:create"
+  }
   const createChat = () => {
+    nextButton = () => {};
     setLoading(true);
-    socket.emit("conversations:create", { participants: state.selected }, ({ success, conversation }) => {
-      const encrypted = conversation.participants.filter(participant => participant.public_key && participant.public_key.length).length == conversation.participants.length;
-      if (encrypted) {
-        initEncryption(ctx, conversation, socket);
-      }
-      if (success) {
-        ctx.addConversation(conversation);
-        navigation.replace("ChatScreen", { conversation });
-      } else {
-        Alert.alert("Error", "Creating new conversation failed, please try again.");
-        setLoading(false);
-      }
-    });
+    createGroup(conversationName).then((group) =>{
+      socket.emit(getSocketAction(), { participants: state.selected, name:conversationName, avatar: conversationAvatar.avatarImage, conversationId: route.params.conversationId }, ({ success, conversation }) => {
+        //const encrypted = conversation.participants.filter(participant => participant.public_key && participant.public_key.length).length == conversation.participants.length;
+        //if (encrypted) {
+        //  initEncryption(ctx, conversation, socket);
+        //}
+        if (success) {
+          ctx.addConversation(conversation);
+          navigation.replace("ChatScreen", { conversation });
+        } else {
+          Alert.alert("Error", "Creating new conversation failed, please try again.");
+          setLoading(false);
+        }
+      });
+    })
   };
 
   const onPress = contact => {
     dispatchToggleSelectionAction(dispatch, contact);
   };
 
+  const pickImage = () => {
+    ImagePicker.openPicker({
+      width: 500,
+      height: 500,
+      cropping: true,
+      cropperCircleOverlay: true,
+      avoidEmptySpaceAroundImage: true,
+    }).then((image) => {
+      let imageFilename =
+        Platform.OS == 'android'
+          ? image.path.replace(/^.*\//, '')
+          : image.filename.toLowerCase();
+      imageFilename = imageFilename.replace(/\.heic$/, '.jpg');
+      setConversationAvatar({
+        avatarImage: image.path,
+        avatarFile: imageFilename,
+        avatarMime: image.mime,
+        default: false,
+      });
+    });
+  };
+
   if (loading) {
     return (
       <View style={styles.loadingContainer}>
@@ -121,20 +250,32 @@ export default function SearchContactsScreen({ navigation }) {
       </View>
     );
   }
-
+  nextButton = createChat;
   return (
     <View style={styles.container}>
-      <Header
-        left={<PillButton text="Cancel" onPress={() => navigation.goBack()} />}
-        right={<PillButton text="Next" onPress={createChat} />}
-        title="Add participants" />
-
-      <TextInput placeholder={"Search"} onChangeText={query => setQuery(query)} />
-
+        <View style={styles.groupRow}>
+      {(route.params.type == 'private' || route.params.type == 'public') &&
+      (<TouchableOpacity onPress={conversationAvatar.default ? pickImage : pickImage} style={styles.avatarContainer}>
+        {conversationAvatar.avatarImage ? 
+        <Image
+          resizeMode="cover"
+          source={{uri: conversationAvatar.avatarImage}}
+          style={styles.profileImage}
+        />
+        :
+        <View style={styles.profileImage}>
+          <Icon name="plus-icon" style={styles.profilePlaceholder}/>
+        </View>
+        }
+      </TouchableOpacity>
+      )}
+      {(route.params.type == 'private' || route.params.type == 'public') && <TextInput hideIcon={true} multiline={false} placeholder={"Group Name"} onChangeText={query => setConversationName(query)} /> }
+      </View>
+      <TextInput multiline={true} placeholder={"Search"} onChangeText={query => setQuery(query)} />
       <FlatList
         style={styles.container}
         data={state.contacts}
-        renderItem={({ item }) => renderContact(item, onPress)}
+        renderItem={({item}) => <SearchResultComponent contacts={friends} contact={item} onPress={onPress} />}
         onEndReached={getMoreUsers} />
     </View>
   );
diff --git a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
index b245cc3..aab586e 100644
--- a/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
+++ b/node_modules/react-native-chat-plugin/SearchContactsScreen/SearchResultComponent.js
@@ -22,7 +22,10 @@ const styles = StyleSheet.create(
       justifyContent: "center",
     },
     name: {
-      fontSize: 16,
+      fontSize: 18,
+    },
+    profileName: {
+      fontSize: 12,
     },
     preview: {
       fontSize: 12,
@@ -43,12 +46,13 @@ const styles = StyleSheet.create(
   }
 );
 
-export default function SearchResultComponent({ contact, onPress }) {
+export default function SearchResultComponent({ contacts, contact, onPress }) {
   return (
     <TouchableOpacity style={styles.container} onPress={() => onPress(contact)}>
       <ProfilePreview text={contact.username} contacts={[contact]} />
       <View style={styles.nameContainer}>
-        <Text style={styles.name}>{contact.username}</Text>
+        <Text style={styles.name}>{contact.name}</Text>
+        <Text style={styles.profileName}>{contacts && Object.keys(contacts).indexOf(contact.username) !== -1 ? contacts[contact.username] : contact.username  }</Text>
       </View>
       {
         contact.selected
diff --git a/node_modules/react-native-chat-plugin/index.js b/node_modules/react-native-chat-plugin/index.js
index 0d59b81..4cf65fa 100644
--- a/node_modules/react-native-chat-plugin/index.js
+++ b/node_modules/react-native-chat-plugin/index.js
@@ -7,29 +7,45 @@ export { addUnreadCountListener, updateCount } from "./utils/unread-counter";
 import { NativeModules } from 'react-native';
 import { SQLCipherClient } from "./utils/SQLCipherClient";
 import { initSocket } from "./utils/SocketIOClient";
-
+import { PermissionsAndroid } from 'react-native';
 export const { ChatPlugin } = NativeModules;
 import Contacts from 'react-native-contacts';
 
 
-export default function ChatModule({ socketIoUrl, options, icon }) {
+export default function ChatModule({ socketIoUrl, options, icon, children }) {
   const [contacts, setContacts] = React.useState([]);
-  const db = React.useMemo(()=> {
-    const getDB = async () => {
-      const db = await SQLCipherClient(options);
-      return db.database;
-    };
-    return getDB();
-  });
+  const getDB = async () => {
+    const db = await SQLCipherClient(options);
+    return db.database;
+  };
   React.useEffect(() => {
-    Contacts.getAll().then(fetchedContacts => {
-      setContacts(fetchedContacts.map((r)=>({value:r.givenName, label: r.givenName})));
-    });
-  });
+    if (Platform.OS == 'android') {
+      PermissionsAndroid.request(
+        PermissionsAndroid.PERMISSIONS.READ_CONTACTS,
+        {
+          'title': 'Contacts',
+          'message': 'This app would like to sync your contacts.',
+          'buttonPositive': 'Allow'
+        }
+      )
+      .then((err)=> {
+        Contacts.getAllWithoutPhotos().then(fetchedContacts => {
+          setContacts(fetchedContacts.filter((r)=>(r.givenName && r.givenName.length)).filter((r)=>(r.phoneNumbers.length > 0 && r.phoneNumbers[0].number.length)).map((r)=>({value:r.givenName, labels:r.phoneNumbers.map(p=>p.number), label: r.phoneNumbers[0].number})));
+        });
+      }
+      );
+    } else {
+      Contacts.getAllWithoutPhotos().then(fetchedContacts => {
+        setContacts(fetchedContacts.filter((r)=>(r.givenName && r.givenName.length)).filter((r)=>(r.phoneNumbers.length > 0 && r.phoneNumbers[0].number.length)).map((r)=>({value:r.givenName, labels:r.phoneNumbers.map(p=>p.number), label: r.phoneNumbers[0].number})));
+      });
+    }
+  },[]);
   initSocket(socketIoUrl);
   return (
-    <ChatContextProvider options={options} socketIoUrl={socketIoUrl} db={db} icon={icon} contacts={contacts}>
-      <ChatContainer options={options} />
+    <ChatContextProvider options={options} socketIoUrl={socketIoUrl} getDB={getDB} icon={icon} contacts={contacts}>
+      <ChatContainer options={options}>
+        {children}
+      </ChatContainer>
     </ChatContextProvider>
   );
 }
diff --git a/node_modules/react-native-chat-plugin/utils/ChatEncryption.js b/node_modules/react-native-chat-plugin/utils/ChatEncryption.js
index 7caec69..068c73b 100644
--- a/node_modules/react-native-chat-plugin/utils/ChatEncryption.js
+++ b/node_modules/react-native-chat-plugin/utils/ChatEncryption.js
@@ -400,6 +400,7 @@ export async function decryptEvents(conversationId, events, private_key, ctx) {
 function sendInitMessage(context, socket, participant, conversationId, conversationKey, public_key, sender_private_key, sender_public_key) {
   return new Promise((resolve, reject) => {
     const initMessage = "G|" + conversationId + "|" + conversationKey;
+    console.error('ERROR', initMessage);
     encryptMessage(initMessage, public_key, sender_private_key).then(({ encryptedMessage, nonce }) => {
       socket.emit("conversations:create", { participants: [participant] }, ({ success, conversation }) => {
         if (success) {
diff --git a/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js b/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
index 8cb4565..d736292 100644
--- a/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
+++ b/node_modules/react-native-chat-plugin/utils/SQLCipherClient.js
@@ -4,7 +4,7 @@ SQLite.DEBUG(false);
 SQLite.enablePromise(true);
 
 let db = null;
-let db_version = 20;
+let db_version = 49;
 export function getEncryptionKeys(context) {
   return new Promise((resolve, reject) => {
     context.getDB().then((db) => {
@@ -48,7 +48,9 @@ function initKeys(token) {
   });
 }
 
+
 function initDB(token) {
+  //console.warn('initDB');
   /**
      Creating new chat:
      1) Generate and save the group_key
@@ -62,6 +64,31 @@ function initDB(token) {
 
      */
   return Promise.all([
+    db.executeSql(
+      `CREATE TABLE files (
+          id INTEGER PRIMARY KEY,
+          created_at INTEGER NOT NULL,
+          path TEXT UNIQUE,
+          contents TEXT,
+          url TEXT,
+          type TEXT,
+          refId TEXT,
+          size INTEGER
+        );`,
+    ),
+    db.executeSql(
+      `CREATE TABLE users (
+          id INTEGER PRIMARY KEY,
+          userId INTEGER UNIQUE NOT NULL,
+          created_at INTEGER NOT NULL,
+          username TEXT,
+          avatarUrl TEXT,
+          avatarFileId TEXT,
+          avatarPath TEXT,
+          phone_number TEXT,
+          seen_at INTEGER
+        );`,
+    ),
     db.executeSql(
       `CREATE TABLE chats (
           id INTEGER PRIMARY KEY,
@@ -77,22 +104,58 @@ function initDB(token) {
     db.executeSql(
       `CREATE TABLE conversations (
           id INTEGER PRIMARY KEY,
-          group_id TEXT NOT NULL,
+          group_id TEXT UNIQUE NOT NULL,
           group_key TEXT NOT NULL,
           name TEXT NOT NULL,
           avatar TEXT,
           created_by TEXT NOT NULL,
-          created_at INTEGER NOT NULL
+          created_at INTEGER NOT NULL,
+          is_pin INTEGER,
+          is_starred INTEGER,
+          is_archive INTEGER,
+          is_mute INTEGER,
+          is_delete INTEGER
+        );`,
+    ),
+
+    db.executeSql(
+      `CREATE TABLE participants (
+          id INTEGER PRIMARY KEY,
+          user_id TEXT NOT NULL,
+          group_id TEXT NOT NULL,
+          created_at INTEGER NOT NULL,
+          UNIQUE(user_id, group_id)
+      );`,
+    ),
+    
+    db.executeSql(
+      `CREATE TABLE calls (
+          id INTEGER PRIMARY KEY,
+          group_id TEXT NOT NULL,
+          call_uuid TEXT,
+          name TEXT NOT NULL,
+          created_by TEXT NOT NULL,
+          created_at INTEGER NOT NULL,
+          duration INTEGER,
+          bytes_total INTEGER,
+          bytes_incoming INTEGER,
+          bytes_outgoing INTEGER
         );`,
     ),
     db.executeSql(
       `CREATE TABLE messages (
           id INTEGER PRIMARY KEY,
-          event_id TEXT UNIQUE,
+          event_id TEXT,
           group_id TEXT NOT NULL,
           author_id TEXT NOT NULL,
           text TEXT NOT NULL,
-          created_at TEXT NOT NULL
+          created_at TEXT NOT NULL,
+          is_starred INTEGER,
+          is_delivered INTEGER,
+          is_read INTEGER,
+          tries INTEGER,
+          retry_at INTEGER,
+          UNIQUE(event_id, created_at)
         );`,
     ),
     db.executeSql(
@@ -112,6 +175,13 @@ function initDB(token) {
           private_key BLOB NOT NULL
         );`,
     ),
+    db.executeSql(
+      `CREATE TABLE settings (
+          id INTEGER PRIMARY KEY,
+          settings TEXT,
+          name TEXT UNIQUE NOT NULL
+        );`,
+    ),
   ]);
 }
 
@@ -144,11 +214,11 @@ function createOrValidateDB(token) {
 
 export function SQLCipherClient(options) {
   return new Promise((resolve, reject) => {
-    if (!db) {
+    if (!db && options) {
       SQLite.openDatabase({
-        name: "chat_" + options.token.substring(0,4) + "_" + db_version + ".db",
+        name: "chat_" + db_version + ".db",
         location: "default",
-        key: options.token,
+        key: options.token.slice(0,10),
       }).then(
         (dbInstance) => {
           db = dbInstance;
@@ -165,13 +235,7 @@ export function SQLCipherClient(options) {
         },
       );
     } else {
-      createOrValidateDB(options.token).then(() => {
-        resolve({database: db});
-      }).catch(
-        () => {
-          reject("Failed to connect to DB");
-        },
-      );
+      resolve({database: db});
     }
   });
 }
\ No newline at end of file
diff --git a/node_modules/react-native-chat-plugin/utils/SocketIOClient.js b/node_modules/react-native-chat-plugin/utils/SocketIOClient.js
index 67f1028..0438d14 100644
--- a/node_modules/react-native-chat-plugin/utils/SocketIOClient.js
+++ b/node_modules/react-native-chat-plugin/utils/SocketIOClient.js
@@ -13,10 +13,10 @@ export function getSocket() {
 }
 
 export const initSocket = (socketIoUrl) => {
+  
   if (socket) {
     return socket;
   }
-
   socket = IO(socketIoUrl, {
     path: "/io",
     jsonp: false,
